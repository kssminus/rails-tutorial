\chapter{로그인, 로그아웃} % (fold)
\label{cha:log_in_log_out}

\input{chapters/3rd_edition_note}

새로운 사용자들의 우리 사이트에 가입할 수 있게 되었으니 (~장\ref{cha:sign_up}), 가입한 사용자가 로그인하고 로그아웃 할 수 있도록 할 차례이다. 이번 장에서는 웹상에서 행해지는 가장 일반적인 로그인, 로그아웃에 필요한 세가지 모델을 구현할 것이다.:  사용자가 브라우저를 닫는 순간 ``forgetting'' (섹~션\ref{sec:sessions_and_failed_login}  과 섹~션\ref{sec:logging_in}), \emph{자동으로} 사용자 기억하기 (섹~션\ref{sec:remember_me}),  와\emph{선택적으로} ``remember me'' 체크박스의 선택여부에 따라 사용자를 기억하기 (섹션~\ref{sec:remember_me_checkbox}).\footnote{또다른 일반적인 모델은 세션을 특정시간이 지난 후 만료시키는 것이다. 이 기능은 중요한 기밀 정보를 다루는 은행이나 금융 거래 서비스를 제공하는 사이트에 사용된다.} 

이 장에서 구현할 인증 시스템은 인증 모델을 구현해서 사용자의 로그인 상태을 체크하고, 사용자를 식별할 수 있다. 예를 들어, 이 장에서는 사이트 헤더에 로그인/로그아웃 링크와 프로파일 링크를 추가할 것이다. \ref{cha:updating_showing_and_deleting_users}장에서 보안모델을 적용하여 오직 로그인 한 사용자만 사용자 인덱스 페이지에 접근할 수 있도록 제어하고, 자신의 프로파일 정보만을 수정할 수 있도록 할것이며, 관리자 권한을 가진 사용자만 다른 사용자를 데이터베이스에서 삭제할 수 있는 권한을 가지도록 할 것 이다. 마지막으로 \ref{cha:user_microposts}장은 로그인한 사용자를 식별하여, 이 사용자 프로파일에 결합된 마이크로 포스트를 생성하고, \ref{cha:following_users}장에서는 한 사용자가 다른 사용자를 팔로우 할 수 있는 기능을 추가할 것이다.(이를 통해서 팔로잉하고 있는 사용자의 포스팅 정보를 받을 수 있다.) 


  \section{세션}
  \label{sec:sessions_and_failed_login}

\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol}{HTTP} 는\href{https://en.wikipedia.org/wiki/Stateless_protocol}{\emph{stateless protocol}}, 각각의 요청을 독립된 트랜젝션으로 이전 요청의 정보를 사용할 수 없다. 이 말의 의미는 페이지와 페이지을 이동할때 사용자를 기억할 방법이 없다는 것이다.\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP_session_state}{within the hypertext transfer protocol}; 대신 웹 어플리케이션은 사용자가 로그인 했을때 \href{http://en.wikipedia.org/wiki/Session_(computer_science)}{\emph{세션}}을 생성하여 두 컴퓨터간에 반영구적 연결을 만든다. (클라이언트 컴퓨터에서 구동되는 브라우저와 레일즈가 구동되고 있는 웹서버). 

레일즈에서 세션을 구현하는 가장 일반적인 방법은 사용자 브라우저에 저장해 놓을 수 있는 짧은 문자열인 \href{http://en.wikipedia.org/wiki/HTTP_cookie}{\emph{쿠키}}이다. 쿠키는 하나의 페이지에서 다른 페이지로 계속 유지 되기때문에, 사용자의 아이디와 같은 정보를 저장해놓고, 데이터베이스에서 이 아이디를 이용해 사용자 객체를 검색할 수 있다. 이번 섹션과 섹션 \ref{sec:logging_in}에서는 브라우저를 닫으면 만료되는 임시 세션인 \kode{session} 메서드를 사용하고, \footnote{몇몇 브라우저는 이 세션을 복구하는 기능인 ``이어서 브라우징''기능을 제공하기도 하지만, 이 기능은 레일즈의 기능을 아니다.}과  섹션\ref{sec:remember_me}에서는 더 생명주기가 긴 레일즈의 다른 메서드인 \kode{cookies}를 살펴 볼 것이다.. 

세션을 RESTful 리소스를 만드는것은 여러모로 편리하다: 로그인 페이지는 \emph{새 세션}을 만드는 폼을 렌더링하,고 로그인 자체는 \emph{세션 생성}, 로그아웃은\emph{세션 삭제}로 매칭된다. 데이터를 유지시키기 위해 데이터 베이스를 사용하는 사용자 리소스와 달리, 세션 리소스는 쿠키를 사용하여 로그인에 관련된 쿠키기반 인증 기능을 구현하는데 사용한다. 이 섹션과 다음 섹션에서 이에 필요한 세션 컨트롤러, 로그인 폼, 여기서 사용할 각각의 액션을 작성할 것이다. 그리고 사용자 로그인 섹션을 마무리하고 세션 조작 코드를 추가할 것이다. 

이전 장에서 토픽 브랜치에 작업한 내용을 머지했다:

%= lang:console
\begin{code}
$ git checkout master
$ git checkout -b log-in-log-out
\end{code}

    \subsection{Sessions controller} % (fold)
    \label{sec:sessions_controller}

로그인과 로그아웃 기능은 각각 세션 컨트롤러의 특정 REST 액션과 대응된다: 로그인 폼은 \kode{new} 액션(이 섹션에서 다룰), 실제 로그인 동작은 <ul>{create}액션(section \ref{sec:logging_in})으로 \texttt{POST} 요청을 보내는 것이고 , 로그 아웃은 \kode{destroy} 액션 (섹션 \ref{sec:logging_out})에 \texttt{DELETE} 요청을 보내는 것이다. (표 \ref{table:RESTful_users} HTTP 메서드와 REST의 매칭) 

먼저 세션 컨트롤러의 \kode{new} 액션을 생성한다: 

%= lang:console
\begin{code}
$ rails generate controller Sessions new
\end{code}

\noindent (\kode{new} 명령은 실제로 \emph{뷰}도 같이 생성한다. 이 컨트롤러는 뷰에서 앞으로 사용하지 않을 \kode{create} 와 \kode{delete} 액션도 만들어낸다.) 섹~션\ref{sec:signup_form} 에서 등장하는 가입하기 페이지의 모델에서 처럼 새로운 세션을 만들기 위한 로그인 폼을 만들 예정이다. 목업은 표 \ref{fig:login_mockup}에 있다. 

\begin{figure}
\begin{center}
\imagebox{images/figures/login_mockup.png}
\end{center}
\caption{A mockup of the login form.\label{fig:login_mockup}}
\end{figure}

자동으로 \kode{resources} 메서드로 자동으로 완벽한 RESTful 라우트 만드는 사용자 리소스와는 달리 (목록 \ref{code:users_resource}), 세션 리소스는 이름 붙여진 라우트를 사용할 것이다.  \texttt{GET} 과 \texttt{POST} 요청는 \kode{login} 라우트로 \texttt{DELETE} 요청은  \kode{logout} 라우트로 처리할 것이다. 결과는 표\ref{code:sessions_resource}와 같다. (\kode{레일즈가 생성한 컨트롤러}에 사용하지 않는 라우트를 제거할 수 있다.) 

\begin{codelisting}
\label{code:sessions_resource}
codecaption{세션을 위한 표준 RESTful 액션 추가 하기. 코드\\코드\filepath{config/routes.rb}} 

%= lang:ruby, options: "hl_lines": [7, 8, 9]
\begin{code}
Rails.application.routes.draw do
  root                'static_pages#home'
  get    'help'    => 'static_pages#help'
  get    'about'   => 'static_pages#about'
  get    'contact' => 'static_pages#contact'
  get    'signup'  => 'users#new'
  get    'login'   => 'sessions#new'
  post   'login'   => 'sessions#create'
  delete 'logout'  => 'sessions#destroy'
  resources :users
end
\end{code}
\end{codelisting}

\noindent The routes defined in Listing~\ref{code:sessions_resource} correspond to URLs and actions similar to those for users (Table~\ref{table:RESTful_users}), as shown in Table~\ref{table:RESTful_sessions}.

\begin{table}
\begin{center}
\footnotesize
\begin{tabular}{lllll}
\textbf{HTTP request} & \textbf{URL} & \textbf{Named route} & \textbf{Action} & \textbf{Purpose} \\ \hline
\texttt{GET} & /login & \kode{login\_path} & \kode{new} & page for  a new session (login) \\
\texttt{POST} & /login & \kode{login\_path} & \kode{create} & create a new session (login) \\
\texttt{DELETE} & /logout & \kode{logout\_path} & \kode{destroy} & delete a session (log out)
\end{tabular}
\end{center}
\caption{Routes provided by the sessions rules in Listing~\ref{code:sessions_resource}.\label{table:RESTful_sessions}}
\end{table}

Since we've now added several custom named routes, it's useful to look at the complete list of the routes for our application, which we can generate using \kode{rake routes}:

%= lang:text
\begin{code}
$ bundle exec rake routes
 Prefix Verb   URI Pattern               Controller#Action
     root GET    /                         static_pages#home
     help GET    /help(.:format)           static_pages#help
    about GET    /about(.:format)          static_pages#about
  contact GET    /contact(.:format)        static_pages#contact
   signup GET    /signup(.:format)         users#new
    login GET    /login(.:format)          sessions#new
          POST   /login(.:format)          sessions#create
   logout DELETE /logout(.:format)         sessions#destroy
    users GET    /users(.:format)          users#index
          POST   /users(.:format)          users#create
 new_user GET    /users/new(.:format)      users#new
edit_user GET    /users/:id/edit(.:format) users#edit
     user GET    /users/:id(.:format)      users#show
          PATCH  /users/:id(.:format)      users#update
          PUT    /users/:id(.:format)      users#update
          DELETE /users/:id(.:format)      users#destroy
\end{code}

\noindent It's not necessary to understand the results in detail, but viewing the routes in this manner gives us a high-level overview of the actions supported by our application.

    % subsection sessions_controller (end)

  \subsection{Login form} % (fold)
  \label{sec:login_form}

Having defined the relevant controller and route, now we'll fill in the view for new sessions, i.e., the login form. Comparing Figure~\ref{fig:login_mockup} with Figure~\ref{fig:signup_mockup}, we see that the login form is similar in appearance to the signup form, except with two fields (email and password) in place of four.

As seen in Figure~\ref{fig:login_failure_mockup}, when the login information is invalid we want to re-render the login page and display an error message. In Section~\ref{sec:signup_error_messages}, we used an error-messages partial to display error messages, but we saw in that section that those messages are provided automatically by Active Record. This won't work for session creation errors because the session isn't an Active Record object, so we'll render the error as a flash message instead.

\begin{figure}
\begin{center}
\imagebox{images/figures/login_failure_mockup.png}
\end{center}
\caption{A mockup of login failure.\label{fig:login_failure_mockup}}
\end{figure}

Recall from Listing~\ref{code:signup_form} that the signup form uses the \kode{form\_for} helper, taking as an argument the user instance variable \kode{@user}:

%= lang:rhtml
\begin{code}
<%= form_for(@user) do |f| %>
  .
  .
  .
<% end %>
\end{code}

\noindent The main difference between the session form and the signup form is that we have no Session model, and hence no analogue for the \kode{@user} variable. This means that, in constructing the new session form, we have to give \kode{form\_for} slightly more information; in particular, whereas

%= lang:ruby
\begin{code}
form_for(@user)
\end{code}

\noindent allows Rails to infer that the \kode{action} of the form should be to \texttt{POST} to the URL /users, in the case of sessions we need to indicate the \emph{name} of the resource and the corresponding URL:\footnote{A second option is to use \kode{form\_tag} in place of \kode{form\_for}, which might be even more idiomatically correct Rails, but it has less in common with the signup form, and at this stage I want to emphasize the parallel structure.}

%= lang:ruby
\begin{code}
form_for(:session, url: login_path)
\end{code}

With the proper \kode{form\_for} in hand, it's easy to make a login form to match the mockup in Figure~\ref{fig:login_mockup} using the signup form (Listing~\ref{code:signup_form}) as a model, as shown in Listing~\ref{code:login_form}.

\begin{codelisting}
\label{code:login_form}
\codecaption{Code for the login form. \\ \filepath{app/views/sessions/new.html.erb}}
%= lang:rhtml
\begin{code}
<% provide(:title, "Log in") %>
<h1>Log in</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(:session, url: login_path) do |f| %>

      <%= f.label :email %>
      <%= f.email_field :email, class: 'form-control' %>

      <%= f.label :password %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.submit "Log in", class: "btn btn-primary" %>
    <% end %>

    <p>New user? <%= link_to "Sign up now!", signup_path %></p>
  </div>
</div>
\end{code}
\end{codelisting}

\noindent Note that we've added a link to the signup page for convenience. With the code in Listing~\ref{code:login_form}, the login form appears as in Figure~\ref{fig:login_form}. (Because the ``Log in'' navigation link hasn't yet been filled in, you'll have to type the /login URL directly into your address bar. We'll fix this blemish in Section~\ref{sec:changing_the_layout_links}.)

\begin{figure}
\begin{center}
\image{images/figures/login_form.png}
\end{center}
\caption{The login form.\label{fig:login_form}}
\end{figure}

The generated form HTML appears in Listing~\ref{code:login_form_html}.

\begin{codelisting}
\label{code:login_form_html}
\codecaption{HTML for the login form produced by Listing~\ref{code:login_form}.}
%= lang:html
\begin{code}
<form accept-charset="UTF-8" action="/login" method="post">
  <input name="utf8" type="hidden" value="&#x2713;" />
  <input name="authenticity_token" type="hidden"
         value="NNb6+J/j46LcrgYUC60wQ2titMuJQ5lLqyAbnbAUkdo=" />
  <label for="session_email">Email</label>
  <input class="form-control" id="session_email"
         name="session[email]" type="text" />
  <label for="session_password">Password</label>
  <input id="session_password" name="session[password]"
         type="password" />
  <input class="btn btn-primary" name="commit" type="submit"
       value="Log in" />
</form>
\end{code}
\end{codelisting}

\noindent Comparing Listing~\ref{code:login_form_html} with Listing~\ref{code:signup_form_html}, you might be able to guess that submitting this form will result in a \kode{params} hash where \kode{params[:ses\-sion]\-[:email]} and \kode{params[:ses\-sion]\-[:password]} correspond to the e\-mail and password fields.

    % subsection login_form (end)

    \subsection{Finding and authenticating a user} % (fold)
    \label{sec:finding_and_authenticating_a_user}

As in the case of creating users (signup), the first step in creating sessions (login) is to handle \emph{invalid} input. We'll start by reviewing what happens when a form gets submitted, and then arrange for helpful error messages to appear in the case of login failure (as mocked up in Figure~\ref{fig:login_failure_mockup}.) Then we'll lay the foundation for successful login (Section~\ref{sec:logging_in}) by evaluating each login submission based on the validity of its email/password combination.

Let's start by defining a minimalist \kode{create} action for the Sessions controller, along with empty \kode{new} and \kode{destroy} actions (Listing~\ref{code:initial_create_session}). The \kode{create} action in Listing~\ref{code:initial_create_session} does nothing but render the \kode{new} view, but it's enough to get us started. Submitting the \href{http://localhost:3000/sessions/new}{/sessions/new} form then yields the result shown in Figure~\ref{fig:initial_failed_login_rails_3}.

\begin{codelisting}
\label{code:initial_create_session}
\codecaption{A preliminary version of the Sessions \kode{create} action. \\ \filepath{app/controllers/sessions\_controller.rb}}
%= lang:ruby, options: "hl_lines": [7]
\begin{code}
class SessionsController < ApplicationController

  def new
  end

  def create
    render 'new'
  end

  def destroy
  end
end
\end{code}
\end{codelisting}

\begin{figure}
\begin{center}
\image{images/figures/initial_failed_login_3rd_edition.png}
\end{center}
\caption{The initial failed login, with \kode{create} as in Listing~\ref{code:initial_create_session}.\label{fig:initial_failed_login_rails_3}}
\end{figure}

Carefully inspecting the debug information in Figure~\ref{fig:initial_failed_login_rails_3} shows that, as hinted at the end of Section~\ref{sec:login_form}, the submission results in a \kode{params} hash containing the email and password under the key \kode{session}, which (omitting some irrelevant details used internally by Rails) appears as follows:

%= lang:yaml
\begin{code}
---
session:
  email: 'user@example.com'
  password: 'foobar'
commit: Log in
action: create
controller: sessions
\end{code}

\noindent As with the case of user signup (Figure~\ref{fig:signup_failure}), these parameters form a \emph{nested} hash like the one we saw in Listing~\ref{code:nested_hashes}. In particular, \kode{params} contains a nested hash of the form

%= lang:ruby
\begin{code}
{ session: { password: "foobar", email: "user@example.com" } }
\end{code}

\noindent This means that

%= lang:ruby
\begin{code}
params[:session]
\end{code}

\noindent is itself a hash:

%= lang:ruby
\begin{code}
{ password: "foobar", email: "user@example.com" }
\end{code}

\noindent As a result,

%= lang:ruby
\begin{code}
params[:session][:email]
\end{code}

\noindent is the submitted email address and

%= lang:ruby
\begin{code}
params[:session][:password]
\end{code}

\noindent is the submitted password.

In other words, inside the \kode{create} action the \kode{params} hash has all the information needed to authenticate users by email and password. Not coincidentally, we already have exactly the methods we need: the \kode{User.find\_by} method provided by Active Record (Section~\ref{sec:finding_user_objects}) and the \kode{authenticate} method provided by \kode{has\_secure\_password} (Section~\ref{sec:creating_and_authenticating_a_user}). Recalling that \kode{auth\-en\-ti\-cate} returns \kode{false} for an invalid authentication (Section~\ref{sec:creating_and_authenticating_a_user}), our strategy for user login can be summarized as shown in Listing~\ref{code:find_authenticate_user}.


\begin{codelisting}
\label{code:find_authenticate_user}
\codecaption{Finding and authenticating a user. \\ \filepath{app/controllers/sessions\_controller.rb}}
%= lang:ruby, options: "hl_lines": [7, 8]
\begin{code}
class SessionsController < ApplicationController

  def new
  end

  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      # Log the user in and redirect to the user's show page.
    else
      # Create an error message.
      render 'new'
    end
  end

  def destroy
  end
end
\end{code}
\end{codelisting}


\noindent The first highlighted line in Listing~\ref{code:find_authenticate_user} pulls the user out of the database using the submitted email address. (Recall from Section~\ref{sec:uniqueness_validation} that email addresses are saved as all lower-case, so here we use the \kode{downcase} method to ensure a match when the submitted address is valid.) The next line can be a bit confusing but is fairly common in idiomatic Rails programming:

%= lang:ruby
\begin{code}
user && user.authenticate(params[:session][:password])
\end{code}

\noindent This uses \kode{\&\&} (logical \emph{and}) to determine if the resulting user is valid. Taking into account that any object other than \kode{nil} and \kode{false} itself is \kode{true} in a boolean context (Section~\ref{sec:objects_and_message_passing}), the possibilities appear as in Table~\ref{table:user_and_and}. We see from Table~\ref{table:user_and_and} that the \kode{if} statement is \kode{true} only if a user with the given email both exists in the database and has the given password, exactly as required.

\begin{table}
\begin{center}
\footnotesize
\begin{tabular}{lllll}
\textbf{User} & \textbf{Password} & \textbf{a \&\& b} \\ \hline
nonexistent & \emph{anything} & \kode{(nil \&\& [anything]) == false} \\
valid user &  wrong password & \kode{(true \&\& false) == false} \\
valid user & right password & \kode{(true \&\& true) == true}
\end{tabular}
\end{center}
\caption{Possible results of \kode{user \&\& user.authenticate(\ldots)}.\label{table:user_and_and}}
\end{table}

    % subsection finding_and_authenticating_a_user (end)

    \subsection{Rendering with a flash message} % (fold)
    \label{sec:rendering_with_a_flash_message}

Recall from Section~\ref{sec:signup_error_messages} that we displayed signup errors using the User model error messages. These errors are associated with a particular Active Record object, but this strategy won't work here because the session isn't an Active Record model. Instead, we'll put a message in the flash to be displayed upon failed login. A first, slightly incorrect, attempt appears in Listing~\ref{code:failed_login_attempt}.

\begin{codelisting}
\label{code:failed_login_attempt}
\codecaption{An (unsuccessful) attempt at handling failed login. \\ \filepath{app/controllers/sessions\_controller.rb}}
%= lang:ruby, options: "hl_lines": [11]
\begin{code}
class SessionsController < ApplicationController

  def new
  end

  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      # Log the user in and redirect to the user's show page.
    else
      flash[:danger] = 'Invalid email/password combination' # Not quite right!
      render 'new'
    end
  end

  def destroy
  end
end
\end{code}
\end{codelisting}

\noindent Because of the flash message display in the site layout (Listing~\ref{code:layout_flash}), the \kode{flash\-[:danger]} message automatically gets displayed; because of the Bootstrap CSS, it automatically gets nice styling (Figure~\ref{fig:failed_login_flash}).

\begin{figure}
\begin{center}
\image{images/figures/failed_login_flash_3rd_edition.png}
\end{center}
\caption{The flash message for a failed login.\label{fig:failed_login_flash}}
\end{figure}

Unfortunately, as noted in the text and in the comment in Listing~\ref{code:failed_login_attempt}, this code isn't quite right. The page looks fine, though, so what's the problem? The issue is that the contents of the flash persist for one \emph{request}, but---unlike a redirect, which we used in Listing~\ref{code:signup_flash}---re-rendering a template with \kode{render} doesn't count as a request. The result is that the flash message persists one request longer than we want. For example, if we submit invalid login information and then click on the Home page, the flash gets displayed a second time (Figure~\ref{fig:flash_persistence}). Fixing this blemish is the task of Section~\ref{sec:a_flash_test}.

\begin{figure}
\begin{center}
\image{images/figures/flash_persistence_3rd_edition.png}
\end{center}
\caption{An example of flash persistence.\label{fig:flash_persistence}}
\end{figure}


    % subsubsection rendering_with_a_flash_message (end)

  \subsection{A flash test} % (fold)
  \label{sec:a_flash_test}

The incorrect flash behavior is a minor bug in our application. According to the testing guidelines from Box~\ref{aside:when_to_test}, this is exactly the sort of situation where we should write a test to catch the error so that it doesn't recur. We'll thus write a short integration test for the login form submission before proceeding. In addition to documenting the bug and preventing a regression, this will also give us a good foundation for further integration tests of login and logout.

We start by generating an integration test for our application's login behavior:

%= lang:console, options: "hl_lines": [1]
\begin{code}
$ rails generate integration_test users_login
      invoke  test_unit
      create    test/integration/users_login_test.rb
\end{code}

\noindent Next, we need a test to capture the sequence shown in Figure~\ref{fig:failed_login_flash} and Figure~\ref{fig:flash_persistence}. The basic steps appear as follows:

\begin{enumerate}
\item Visit the login path.
\item Verify that the new sessions form renders properly.
\item Post to the sessions path with an invalid \kode{params} hash.
\item Verify that the new sessions form gets re-rendered and that a flash message appears.
\item Visit another page (such as the Home page).
\item Verify that the flash message \emph{doesn't} appear on the new page.
\end{enumerate}

\noindent A test implementing the above steps appears in Listing~\ref{code:flash_persistence_test}.

\newpage

\begin{codelisting}
\label{code:flash_persistence_test}
\codecaption{A test to catch unwanted flash persistence. \failing \\ \filepath{test/integration/users\_login\_test.rb}}
%= lang:ruby
\begin{code}
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest

  test "login with invalid information" do
    get login_path
    assert_template 'sessions/new'
    post login_path, session: { email: "", password: "" }
    assert_template 'sessions/new'
    assert_not flash.empty?
    get root_path
    assert flash.empty?
  end
end
\end{code}
\end{codelisting}

After adding the test in Listing~\ref{code:flash_persistence_test}, the login test should be \failing:

\begin{codelisting}
\codecaption{\failing}
%= lang:text
\begin{code}
$ bundle exec rake test TEST=test/integration/users_login_test.rb
\end{code}
\end{codelisting}

\noindent This shows how to run one (and only one) test file using the argument \kode{TEST} and the full path to the file.

The way to get the failing test in Listing~\ref{code:flash_persistence_test} to pass is to replace \kode{flash} with the special variant \kode{flash.now}, which is specifically designed for displaying flash messages on rendered pages. Unlike the contents of \kode{flash}, the contents of \kode{flash.now} disappear as soon as there is an additional request, which is exactly the behavior we've tested in Listing~\ref{code:flash_persistence_test}. With this substitution, the corrected application code appears as in Listing~\ref{code:correct_login_failure}.

\begin{codelisting}
\label{code:correct_login_failure}
\codecaption{Correct code for failed login. \passing \\ \filepath{app/controllers/sessions\_controller.rb}}
%= lang:ruby, options: "hl_lines": [11]
\begin{code}
class SessionsController < ApplicationController

  def new
  end

  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      # Log the user in and redirect to the user's show page.
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end

  def destroy
  end
end
\end{code}
\end{codelisting}

We can then verify that both the login integration test and the full test suite are \passing:

\begin{codelisting}
\codecaption{\passing}
%= lang:text
\begin{code}
$ bundle exec rake test TEST=test/integration/users_login_test.rb
$ bundle exec rake test
\end{code}
\end{codelisting}

  % subsection a_flash_test (end)

  % section login_failure (end)

  \section{Logging in} % (fold)
  \label{sec:logging_in}

Now that our login form can handle invalid submissions, the next step is to handle valid submissions correctly by actually logging a user in. In this section, we'll log the user in with a temporary session cookie that expires automatically upon browser close. In Section~\ref{sec:remember_me}, we'll add sessions that persist even after closing the browser.

Implementing sessions will involve defining a large number of related functions for use across multiple controllers and views. You may recall from Section~\ref{sec:back_to_the_title_helper} that Ruby provides a \emph{module} facility for packaging such functions in one place. Conveniently, a Sessions helper module was generated automatically when generating the Sessions controller (Section~\ref{sec:sessions_controller}). Moreover, such helpers are automatically included in Rails views; by including the module into the base class of all controllers (the Application controller), we arrange to make them available in our controllers as well (Listing~\ref{code:sessions_helper_include}).

\begin{codelisting}
\label{code:sessions_helper_include}
\codecaption{Including the Sessions helper module into the Application controller. \\ \filepath{app/controllers/application\_controller.rb}}
%= lang:ruby, options: "hl_lines": [3]
\begin{code}
class ApplicationController < ActionController::Base
  protect_from_forgery with: :exception
  include SessionsHelper
end
\end{code}
\end{codelisting}

\noindent With this configuration complete, we're now ready to write the code to log users in.


    \subsection{The \texttt{log\_in} method} % (fold)
    \label{sec:a_working_log_in_method}

Logging a user in is simple with the help of the \kode{session} method defined by Rails. (This method is separate and distinct from the Sessions controller generated in Section~\ref{sec:sessions_controller}.) We can treat \kode{session} as if it were a hash, and assign to it as follows:

%= lang:ruby
\begin{code}
session[:user_id] = user.id
\end{code}

\noindent This places a temporary cookie on the user's browser containing an encrypted version of the user's id, which allows us to retrieve the id on subsequent pages using \kode{session[:user\_id]}. In contrast to the persistent cookie created by the \kode{cookies} method (Section~\ref{sec:remember_me}), the temporary cookie created by the \kode{session} method expires immediately when the browser is closed.

Because we'll want to use the same login technique in a couple of different places, we'll define a method called \kode{log\_in} in the Sessions helper, as shown in Listing~\ref{code:log_in_function}.

\begin{codelisting}
\label{code:log_in_function}
\codecaption{The \kode{log\_in} function. \\ \filepath{app/helpers/sessions\_helper.rb}}
%= lang:ruby, options: "hl_lines": [5]
\begin{code}
module SessionsHelper

  # Logs in the given user.
  def log_in(user)
    session[:user_id] = user.id
  end
end
\end{code}
\end{codelisting}

Because temporary cookies created using the \kode{session} method are automatically encrypted, the code in Listing~\ref{code:log_in_function} is secure, and there is no way for an attacker to use the session information to log in as the user. This applies only to temporary sessions initiated with the \kode{session} method, though, and is \emph{not} the case for persistent sessions created using the \kode{cookies} method. Permanent cookies are vulnerable to a \emph{session hijacking} attack, so in Section~\ref{sec:remember_me} we'll have to be much more careful about the information we place on the user's browser.

With the \kode{log\_in} method defined in Listing~\ref{code:log_in_function}, we're now ready to complete the session \kode{create} action by logging the user in and redirecting to the user's profile page. The result appears in Listing~\ref{code:log_in_success}.\footnote{The \kode{log\_in} method is available in the Sessions controller because of the module inclusion in Listing~\ref{code:sessions_helper_include}.}

\begin{codelisting}
\label{code:log_in_success}
\codecaption{Logging in a user. \\ \filepath{app/controllers/sessions\_controller.rb}}
%= lang:ruby, options: "hl_lines": [9, 10]
\begin{code}
class SessionsController < ApplicationController

  def new
  end

  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      log_in user
      redirect_to user
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end

  def destroy
  end
end
\end{code}
\end{codelisting}

\noindent Note the compact redirect

%= lang:ruby
\begin{code}
redirect_to user
\end{code}

\noindent which we saw before in Section~\ref{sec:the_finished_signup_form}. Rails automatically converts this to the route for the user's profile page:

%= lang:ruby
\begin{code}
user_url(user)
\end{code}

With the \kode{create} action defined in Listing~\ref{code:log_in_success}, the login form defined in Listing~\ref{code:login_form} should now be working. It doesn't have any effects on the application display, though, so short of inspecting the browser session directly there's no way to tell that you're logged in. As a first step toward enabling more visible changes, in Section~\ref{sec:current_user} we'll retrieve the current user from the database using the id in the session. In Section~\ref{sec:changing_the_layout_links}, we'll change the links on the application layout, including a URL to the current user's profile.

    % subsection a_working_log_in_method (end)


\subsection{Current user} % (fold)
\label{sec:current_user}

Having placed the user's id securely in the temporary session, we are now in a position to retrieve it on subsequent pages, which we'll do by defining a \kode{current\_user} method to find the user in the database corresponding to the session id. The purpose of \kode{current\_user} is to allow constructions such as

%= lang:rhtml
\begin{code}
<%= current_user.name %>
\end{code}

\noindent and

%= lang:ruby
\begin{code}
redirect_to current_user
\end{code}

To find the current user, one possibility is to use the \kode{find} method, as on the user profile page (Listing~\ref{code:user_show_action}):

%= lang:ruby
\begin{code}
User.find(session[:user_id])
\end{code}

\noindent But recall from Section~\ref{sec:finding_user_objects} that \kode{find} raises an exception if the user id doesn't exist. This behavior is appropriate on the user profile page because it will only happen if the id is invalid, but in the present case \kode{session[:user\_id]} will often be \kode{nil} (i.e., for non-logged-in users). To handle this possibility, we'll use the same \kode{find\_by} method used to find by email address in the \kode{create} method, with \kode{id} in place of \kode{email}:

%= lang:ruby
\begin{code}
User.find_by(id: session[:user_id])
\end{code}

\noindent Rather than raising an exception, this method returns \kode{nil} (indicating no such user) if the id is invalid.

We could now define the \kode{current\_user} method as follows:

%= lang:ruby
\begin{code}
def current_user
  User.find_by(id: session[:user_id])
end
\end{code}

\noindent This would work fine, but it would hit the database multiple times if, e.g., \kode{current\_user} appeared multiple times on a page. Instead, we'll follow a common Ruby convention by storing the result of \kode{User.find\_by} in an instance variable, which hits the database the first time but returns the instance variable immediately on subsequent invocations:\footnote{This practice of remembering variable assignments from one method invocation to the next is known as \href{http://en.wikipedia.org/wiki/Memoization}{\emph{memoization}}. (Note that this is a technical term; in particular, it's \emph{not} a misspelling of ``memorization''.)}

%= lang:ruby
\begin{code}
if @current_user.nil?
  @current_user = User.find_by(id: session[:user_id])
else
  @current_user
end
\end{code}

\noindent Recalling the \emph{or}~operator \texttt{||} seen in Section~\ref{sec:objects_and_message_passing}, we can rewrite this as follows:

%= lang:ruby
\begin{code}
@current_user = @current_user || User.find_by(id: session[:user_id])
\end{code}

\noindent Because a User object is true in a boolean context, the call to \kode{find\_by} only gets executed if \kode{@current\_user} hasn't yet been assigned.

Although the preceding code would work, it's not idiomatically correct Ruby; instead, the proper way to write the assignment to \kode{@current\_user} is like this:

%= lang:ruby
\begin{code}
@current_user ||= User.find_by(id: session[:user_id])
\end{code}

\noindent This uses the potentially confusing but frequently used \kode{||=} (``or equals'') operator (Box~\ref{aside:or_equals}).


\begin{aside}
\label{aside:or_equals}
\heading{What the *\$@! is \texttt{||=} ? }

The \texttt{||=} (``or equals'') assignment operator is a common Ruby idiom and is thus important for aspiring Rails developers to recognize. Although at first it may seem mysterious, \emph{or equals} is easy to understand by analogy.

We start by noting the common pattern of incrementing a variable:

\begin{verbatim}
  x = x + 1
\end{verbatim}

\noindent Many languages provide a syntactic shortcut for this operation; in Ruby (and in C, C++, Perl, Python, Java, etc.), it can also appear as follows:

\begin{verbatim}
  x += 1
\end{verbatim}

\noindent Analogous constructs exist for other operators as well:

\begin{verbatim}
  $ rails console
  >> x = 1
  => 1
  >> x += 1
  => 2
  >> x *= 3
  => 6
  >> x -= 8
  => -2
  >> x /= 2
  => -1
\end{verbatim}

\noindent In each case, the pattern is that \texttt{x = x O y} and \texttt{x O= y} are equivalent for any operator \texttt{O}.

Another common Ruby pattern is assigning to a variable if it's \texttt{nil} but otherwise leaving it alone. Recalling the \emph{or}~operator \texttt{||} seen in Section~\ref{sec:objects_and_message_passing}, we can write this as follows:

\begin{verbatim}
  >> @foo
  => nil
  >> @foo = @foo || "bar"
  => "bar"
  >> @foo = @foo || "baz"
  => "bar"
\end{verbatim}

\noindent Since \texttt{nil} is false in a boolean context, the first assignment to \texttt{@foo} is \texttt{nil || "bar"}, which evaluates to \texttt{"bar"}. Similarly, the second assignment is \texttt{@foo || "baz"}, i.e., \texttt{"bar" || "baz"}, which also evaluates to \texttt{"bar"}. This is because anything other than \texttt{nil} or \texttt{false} is \texttt{true} in a boolean context, and the series of \texttt{||} expressions terminates after the first true expression is evaluated. (This practice of evaluating \texttt{||} expressions from left to right and stopping on the first true value is known as \emph{short-circuit evaluation}.)

Comparing the console sessions for the various operators, we see that \texttt{@foo = @foo || "bar"} follows the \texttt{x = x O y} pattern with \texttt{||} in the place of \texttt{O}:

\begin{verbatim}
  x    =   x   +   1      ->     x     +=   1
  x    =   x   *   3      ->     x     *=   3
  x    =   x   -   8      ->     x     -=   8
  x    =   x   /   2      ->     x     /=   2
  @foo = @foo || "bar"    ->     @foo ||= "bar"
\end{verbatim}


\noindent Thus we see that \verb+@foo = @foo || "bar"+ and \verb+@foo ||= "bar"+ are equivalent. In the context of the current user, this suggests the following construction:

\begin{verbatim}
@current_user ||= User.find_by(id: session[:user_id])
\end{verbatim}

\noindent Voil\`{a}~!

\end{aside}

Applying the results of the above discussion yields the succinct \linebreak \kode{cur\-rent\_\-user} method shown in Listing~\ref{code:current_user}.

\begin{codelisting}
\label{code:current_user}
\codecaption{Finding the current user in the session. \\ \filepath{app/helpers/sessions\_helper.rb}}
%= lang:ruby, options: "hl_lines": [10]
\begin{code}
module SessionsHelper

  # Logs in the given user.
  def log_in(user)
    session[:user_id] = user.id
  end

  # Returns the current logged-in user (if any).
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end
end
\end{code}
\end{codelisting}

\noindent With the working \kode{current\_user} method in Listing~\ref{code:current_user}, we're now in a position to make changes to our application based on user login status.

% subsection current_user (end)

    \subsection{Changing the layout links} % (fold)
    \label{sec:changing_the_layout_links}

The first practical application of logging in involves changing the layout links based on login status. In particular, as seen in the Figure~\ref{fig:login_success_mockup} mockup,\footnote{Image from \href{http://www.flickr.com/photos/hermanusbackpackers/3343254977/}{http://www.flickr.com/photos/hermanusbackpackers/3343254977/}.} we'll add links for logging out, for user settings, for listing all users, and for the current user's profile page. Note in Figure~\ref{fig:login_success_mockup} that the logout and profile links appear in a dropdown ``Account'' menu; we'll see in Listing~\ref{code:layout_login_logout_links} how to make such a menu with Bootstrap.

\begin{figure}
\begin{center}
\imagebox{images/figures/login_success_mockup.png}
\end{center}
\caption{A mockup of the user profile after a successful login.\label{fig:login_success_mockup}}
\end{figure}

At this point, in real life I would consider writing an integration test to capture the behavior described above. As noted in Box~\ref{aside:when_to_test}, as you become more familiar with the testing tools in Rails you may find yourself more inclined to write tests first. In this case, though, such a test involves several new ideas, so for now it's best deferred to its own section (Section~\ref{sec:testing_layout_changes}).

The way to change the links in the site layout involves using an
if-else statement inside embedded Ruby to show one set of links if the user is logged in and another set of links otherwise:

%= lang:rhtml
\begin{code}
<% if logged_in? %>
  # Links for logged-in users
<% else %>
  # Links for non-logged-in-users
<% end %>
\end{code}

\noindent This kind of code requires the existence of a \kode{logged\_in?}\ boolean method, which we'll now define.

A user is logged in if there is a current user in the session, i.e., if \linebreak \kode{current\_\-user} is not \kode{nil}. Checking for this requires the use of the ``not'' operator (Section~\ref{sec:objects_and_message_passing}), written using an exclamation point~\kode{!} and usually read as ``bang''. The resulting \kode{logged\_in?}\ method appears in Listing~\ref{code:logged_in_p}.

\begin{codelisting}
\label{code:logged_in_p}
\codecaption{The \kode{logged\_in?}\ helper method. \\ \filepath{app/helpers/sessions\_helper.rb}}
%= lang:ruby, options: "hl_lines": [15]
\begin{code}
module SessionsHelper

  # Logs in the given user.
  def log_in(user)
    session[:user_id] = user.id
  end

  # Returns the current logged-in user (if any).
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in?
    !current_user.nil?
  end
end
\end{code}
\end{codelisting}

With addition in Listing~\ref{code:logged_in_p}, we're now ready to change the layout links if a user is logged in. There are four new links, two of which are stubbed out (to be completed in Chapter~\ref{cha:updating_showing_and_deleting_users}):

%= lang:rhtml
\begin{code}
<%= link_to "Users",    '#' %>
<%= link_to "Settings", '#' %>
\end{code}

\noindent The logout link, meanwhile, uses the logout path defined in Listing~\ref{code:sessions_resource}:

%= lang:rhtml
\begin{code}
<%= link_to "Log out", logout_path, method: :delete %>
\end{code}

\noindent Notice that the logout link passes a hash argument indicating that it should submit with an HTTP \texttt{DELETE} request.\footnote{Web browsers can't actually issue \texttt{DELETE} requests; Rails fakes it with JavaScript.} We'll also add a profile link as follows:

%= lang:rhtml
\begin{code}
<%= link_to "Profile", current_user %>
\end{code}

\noindent Here we could write

%= lang:rhtml
\begin{code}
<%= link_to "Profile", user_path(current_user) %>
\end{code}

\noindent but as usual Rails allows us to link directly to the user by automatically converting \kode{current\_user} into \kode{user\_path(current\_user)} in this context. Finally, when users \emph{aren't} logged in, we'll use the login path defined in Listing~\ref{code:sessions_resource} to make a link to the login form:

%= lang:rhtml
\begin{code}
<%= link_to "Log in", login_path %>
\end{code}

\noindent Putting everything together gives the updated header partial shown in Listing~\ref{code:layout_login_logout_links}.

\begin{codelisting}
\label{code:layout_login_logout_links}
\codecaption{Changing the layout links for logged-in users. \\ \filepath{app/views/layouts/\_header.html.erb}}
%= lang:rhtml, options: "hl_lines": [8, 9, 15, 16, 19, 23, 24, 25]
\begin{code}
<header class="navbar navbar-fixed-top navbar-inverse">
  <div class="container">
    <%= link_to "sample app", root_path, id: "logo" %>
    <nav>
      <ul class="nav navbar-nav navbar-right">
        <li><%= link_to "Home", root_path %></li>
        <li><%= link_to "Help", help_path %></li>
        <% if logged_in? %>
          <li><%= link_to "Users", '#' %></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">
              Account <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
              <li><%= link_to "Profile", current_user %></li>
              <li><%= link_to "Settings", '#' %></li>
              <li class="divider"></li>
              <li>
                <%= link_to "Log out", logout_path, method: "delete" %>
              </li>
            </ul>
          </li>
        <% else %>
          <li><%= link_to "Log in", login_path %></li>
        <% end %>
      </ul>
    </nav>
  </div>
</header>
\end{code}
\end{codelisting}


As part of including the new links into the layout, Listing~\ref{code:layout_login_logout_links} takes advantage of Bootstrap's ability to make dropdown menus.\footnote{See the \href{http://getbootstrap.com/components/}{Bootstrap components page} for more information.} Note in particular the inclusion of the special Bootstrap CSS classes such as \kode{dropdown}, \kode{dropdown-menu}, etc. To activate the dropdown menu, we need to include Bootstrap's custom JavaScript library in the Rails asset pipeline's \kode{ap\-pli\-ca\-tion.js} file, as shown in Listing~\ref{code:bootstrap_js}.

\begin{codelisting}
\label{code:bootstrap_js}
\codecaption{Adding the Bootstrap JavaScript library to \kode{application.js}. \\ \filepath{app/assets/javascripts/application.js}}
%= lang:js, options: "hl_lines": [3]
\begin{code}
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require turbolinks
//= require_tree .
\end{code}
\end{codelisting}

% \noindent This uses the Sprockets library to include the Bootstrap JavaScript, which in turn is available thanks to the \texttt{bootstrap-sass} gem from Section~\ref{sec:custom_css}.

At this point, you should visit the login path and log in as a valid user, which effectively tests the code in the previous three sections.\footnote{If you're using the cloud IDE, I recommend using a different browser to test the login behavior so that you don't have to close down the browser running the IDE.} With the code in Listing~\ref{code:layout_login_logout_links} and Listing~\ref{code:bootstrap_js}, you should see the dropdown menu and links for logged-in users, as shown in Figure~\ref{fig:profile_with_logout_link}. If you quit your browser completely, you should also be able to verify that the application forgets your login status, requiring you to log in again to see the changes described above.

\begin{figure}
\begin{center}
\image{images/figures/profile_with_logout_link_3rd_edition.png}
\end{center}
\caption{A logged-in user with new links and a dropdown menu.\label{fig:profile_with_logout_link}}
\end{figure}

    % subsection changing_the_layout_links (end)

    \subsection{Testing layout changes} % (fold)
    \label{sec:testing_layout_changes}

Having verified by hand that the application is behaving properly upon successful login, before moving on we'll write an integration test to capture that behavior and catch regressions. We'll build on the test from Listing~\ref{code:flash_persistence_test} and write a series of steps to verify the following sequence of actions:

\begin{enumerate}
\item Visit the login path.
\item Post valid information to the sessions path.
\item Verify that the login link disappears.
\item Verify that a logout link appears
\item Verify that a profile link appears.
\end{enumerate}

In order to see these changes, our test needs to log in as a previously registered user, which means that such a user must already exist in the database. The default Rails way to do this is to use \emph{fixtures}, which are a way of organizing data to be loaded into the test database. We discovered in Section~\ref{sec:uniqueness_validation} that we needed to delete the default fixtures so that our email uniqueness tests would pass (Listing~\ref{code:empty_fixtures}). Now we're ready to start filling in that empty file with custom fixtures of our own.

In the present case, we need only one user, whose information should consist of a valid name and email address. Because we'll need to log the user in, we also have to include a valid password to compare with the password submitted to the Sessions controller's \kode{create} action. Referring to the data model in Figure~\ref{fig:user_model_password_digest}, we see that this means creating a \kode{password\_digest} attribute for the user fixture, which we'll accomplish by defining a \kode{digest} method of our own.

As discussed in Section~\ref{sec:a_hashed_password}, the password digest is created using bcrypt (via \kode{has\_secure\_password}), so we'll need to create the fixture password using the same method. By inspecting the \href{https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb}{secure password source code}, we find that this method is

%= lang:ruby
\begin{code}
BCrypt::Password.create(string, cost: cost)
\end{code}

\noindent where \kode{string} is the string to be hashed and \kode{cost} is the \emph{cost parameter} that determines the computational cost to calculate the hash. Using a high cost makes it computationally intractable to use the hash to determine the original password, which is an important security precaution in a production environment, but in tests we want the \kode{digest} method to be as fast as possible. The secure password source code has a line for this as well:

%= lang:ruby
\begin{code}
cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                              BCrypt::Engine.cost
\end{code}

\noindent This rather obscure code, which you don't need to understand in detail, arranges for precisely the behavior described above: it uses the minimum cost parameter in tests and a normal (high) cost parameter in production. (We'll learn more about the strange \kode{?}-\kode{:} notation in Section~\ref{sec:remember_me_checkbox}.)

There are several places we could put the resulting \kode{digest} method, but we'll have an opportunity in Section~\ref{sec:remember_token} to reuse \kode{digest} in the User model. This suggests placing the method in \kode{user.rb}. Because we won't necessarily have access to a user object when calculating the digest (as will be the case in the fixtures file), we'll attach the \kode{digest} method to the User class itself, which (as we saw briefly in Section~\ref{sec:constructors}) makes it a \emph{class method}. The result appears in Listing~\ref{code:digest_method}.

\begin{codelisting}
\label{code:digest_method}
\codecaption{Adding a digest method for use in fixtures. \\ \filepath{app/models/user.rb}}
%= lang:ruby, options: "hl_lines": [13, 14, 15]
\begin{code}
class User < ActiveRecord::Base
  before_save { self.email = email.downcase }
  validates :name,  presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, length: { minimum: 6 }

  # Returns the hash digest of the given string.
  def User.digest(string)
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                  BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
  end
end
\end{code}
\end{codelisting}

With the \kode{digest} method from Listing~\ref{code:digest_method}, we are now ready to create a user fixture for a valid user, as shown in Listing~\ref{code:real_user_fixture}.

\begin{codelisting}
\label{code:real_user_fixture}
\codecaption{A fixture for testing user login. \\ \filepath{test/fixtures/users.yml}}
%= lang:yaml
\begin{code}
michael:
  name: Michael Example
  email: michael@example.com
  password_digest: <%= User.digest('password') %>
\end{code}
\end{codelisting}

\noindent Note in particular that fixtures support embedded Ruby, which allows us to use

%= lang:ruby
\begin{code}
<%= User.digest('password') %>
\end{code}

\noindent to create the valid password digest for the test user.

Although we've defined the \kode{password\_digest} attribute required by \linebreak \kode{has\_secure\_password}, sometimes it's convenient to refer to the plain (virtual) password as well. Unfortunately, this is impossible to arrange with fixtures, and adding a \kode{password} attribute to Listing~\ref{code:real_user_fixture} causes Rails to complain that there is no such column in the database (which is true). We'll make do by adopting the convention that all fixture users have the same password (\kode{'password'}).

Having created a fixture with a valid user, we can retrieve it inside a test as follows:

%= lang:ruby
\begin{code}
user = users(:michael)
\end{code}

\noindent Here \kode{users} corresponds to the fixture filename \kode{users.yml}, while the symbol \kode{:michael} references user with the key shown in Listing~\ref{code:real_user_fixture}.

With the fixture user as above, we can now write a test for the layout links by converting the sequence enumerated at the beginning of this section into code, as shown in Listing~\ref{code:user_login_test_valid_information}. 

\begin{codelisting}
\label{code:user_login_test_valid_information}
\codecaption{A test for user logging in with valid information. \passing \\ \filepath{test/integration/users\_login\_test.rb}}
%= lang:ruby, options: "hl_lines": [5, 6, 7]
\begin{code}
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest

  def setup
    @user = users(:michael)
  end
  .
  .
  .
  test "login with valid information" do
    get login_path
    post login_path, session: { email: @user.email, password: 'password' }
    assert_redirected_to @user
    follow_redirect!
    assert_template 'users/show'
    assert_select "a[href=?]", login_path, count: 0
    assert_select "a[href=?]", logout_path
    assert_select "a[href=?]", user_path(@user)
  end
end
\end{code}
\end{codelisting}

\noindent Here we've used

%= lang:ruby
\begin{code}
assert_redirected_to @user
\end{code}

\noindent to check the right redirect target and

%= lang:ruby
\begin{code}
follow_redirect!
\end{code}

\noindent to actually visit the target page. Listing~\ref{code:user_login_test_valid_information} also verifies that the login link disappears by verifying that there are \emph{zero} login path links on the page:

%= lang:ruby
\begin{code}
assert_select "a[href=?]", login_path, count: 0
\end{code}

\noindent By including the extra \kode{count: 0} option, we tell \kode{assert\_select} that we expect there to be zero links matching the given pattern. (Compare to \kode{count: 2} in Listing~\ref{code:layout_links_test}, which checks for exactly two matching links.)

Because the application code was already working, this test should be \linebreak \passing:

\begin{codelisting}
\codecaption{\passing}
%= lang:text
\begin{code}
$ bundle exec rake test TEST=test/integration/users_login_test.rb \
>                       TESTOPTS="--name test_login_with_valid_information"
\end{code}
\end{codelisting}

\noindent This shows how to run a specific test within a test file by passing the option

%= lang:console
\begin{code}
TESTOPTS="--name test_login_with_valid_information"
\end{code}

\noindent containing the name of the test. (A test's name is just the word ``test'' and the words in the test description joined using underscores.)

    % subsection layout_link_tests (end)

    \subsection{Login upon signup} % (fold)
    \label{sec:login_upon_signup}

Although our authentication system is now working, newly registered users might be confused, as they are not logged in by default. Because it would be strange to force users to log in immediately after signing up, we'll log in new users automatically as part of the signup process. To arrange this behavior, all we need to do is add a call to \kode{log\_in} in the Users controller \kode{create} action, as shown in Listing~\ref{code:login_upon_signup}.\footnote{As with the Sessions controller, the \kode{log\_in} method is available in the Users controller because of the module inclusion in Listing~\ref{code:sessions_helper_include}.}

\begin{codelisting}
\label{code:login_upon_signup}
\codecaption{Logging in the user upon signup. \\ \filepath{app/controllers/users\_controller.rb}}
%= lang:ruby, options: "hl_lines": [14]
\begin{code}
class UsersController < ApplicationController

  def show
    @user = User.find(params[:id])
  end

  def new
    @user = User.new
  end

  def create
    @user = User.new(user_params)
    if @user.save
      log_in @user
      flash[:success] = "Welcome to the Sample App!"
      redirect_to @user
    else
      render 'new'
    end
  end

  private

    def user_params
      params.require(:user).permit(:name, :email, :password,
                                   :password_confirmation)
    end
end
\end{code}
\end{codelisting}

To test the behavior from Listing~\ref{code:login_upon_signup}, we can add a line to the test from Listing~\ref{code:a_test_for_valid_submission} to check that the user is logged in. It's helpful in this context to define a \kode{is\_logged\_in?}\ helper method to parallel the \kode{logged\_in?}\ helper defined in Listing~\ref{code:logged_in_p}, which returns \kode{true} if there's a user id in the (test) session and false otherwise (Listing~\ref{code:test_helper_sessions}). (Because helper methods aren't available in tests, we can't use the \kode{current\_user} as in Listing~\ref{code:logged_in_p}, but the \kode{session} method is available, so we use that instead.) Here we use \kode{is\_logged\_in?}\ instead of \kode{logged\_in?}\ so that the test helper and Sessions helper methods have different names, which prevents them from being mistaken for each other.\footnote{For example, I once had a test suite that was \passing\ even after accidentally deleting the main \kode{log\_in} method in the Sessions helper. The reason is that the tests were happily using a test helper with the same name, thereby passing even though the application was completely broken. As with \kode{is\_logged\_in?}, we'll avoid this issue by defining the test helper \kode{log\_in\_as} in Listing~\ref{code:test_helper_log_in}.}

\begin{codelisting}
\label{code:test_helper_sessions}
\codecaption{A boolean method for login status inside tests. \\ \filepath{test/test\_helper.rb}}
%= lang:ruby, options: "hl_lines": [9, 10, 11]
\begin{code}
ENV['RAILS_ENV'] ||= 'test'
.
.
.
class ActiveSupport::TestCase
  fixtures :all

  # Returns true if a test user is logged in.
  def is_logged_in?
    !session[:user_id].nil?
  end
end
\end{code}
\end{codelisting}

\noindent With the code in Listing~\ref{code:test_helper_sessions}, we can assert that the user is logged in after signup using the line shown in  Listing~\ref{code:login_after_signup_test}.

\begin{codelisting}
\label{code:login_after_signup_test}
\codecaption{A test of login after signup. \passing \\ \filepath{test/integration/users\_signup\_test.rb}}
%= lang:ruby, options: "hl_lines": [16]
\begin{code}
require 'test_helper'

class UsersSignupTest < ActionDispatch::IntegrationTest
  .
  .
  .
  test "valid signup information" do
    get signup_path
    assert_difference 'User.count', 1 do
      post_via_redirect users_path, user: { name:  "Example User",
                                            email: "user@example.com",
                                            password:              "password",
                                            password_confirmation: "password" }
    end
    assert_template 'users/show'
    assert is_logged_in?
  end
end
\end{code}
\end{codelisting}

At this point, the test suite should still be \passing:

\begin{codelisting}
\codecaption{\passing}
%= lang:text
\begin{code}
$ bundle exec rake test
\end{code}
\end{codelisting}

    % subsection login_upon_signup (end)

  % section login_success (end)

  \section{Logging out} % (fold)
  \label{sec:logging_out}

As discussed in Section~\ref{sec:sessions_and_failed_login}, our authentication model is to keep users logged in until they log out explicitly. In this section, we'll add this necessary logout capability. Because the ``Log out'' link has already been defined (Listing~\ref{code:layout_login_logout_links}), all we need is to write a valid controller action to destroy user sessions.

So far, the Sessions controller actions have followed the RESTful convention of using \kode{new} for a login page and \kode{create} to complete the login. We'll continue this theme by using a \kode{destroy} action to delete sessions, i.e., to log out. Unlike the login functionality, which we use in both Listing~\ref{code:log_in_success} and Listing~\ref{code:login_upon_signup}, we'll only be logging out in one place, so we'll put the relevant code directly in the \kode{destroy} action. As we'll see in Section~\ref{sec:remember_tests}, this design (with a little refactoring) will also make the authentication machinery easier to test.

Logging out involves undoing the effects of the \kode{log\_in} method from Listing~\ref{code:log_in_function}, which involves deleting the user id from the session.\footnote{Some browsers offer a ``\href{http://stackoverflow.com/questions/20449641/rails-4-session-value-never-expires-or-dies-when-browser-closes}{remember where I left off}'' feature, which restores the session automatically, so be sure to disable any such feature before trying to log out.} To do this, we use the \kode{delete} method as follows:

%= lang:ruby
\begin{code}
session.delete(:user_id)
\end{code}

\noindent We'll also set the current user to \kode{nil}, although in the present case this won't matter because of an immediate redirect to the root URL.\footnote{Setting \kode{@current\_user} to \kode{nil} would only matter if \kode{@current\_user} were created before the \kode{destroy} action (which it isn't) \emph{and} if we didn't issue an immediate redirect (which we do). This is an unlikely combination of events, and with the application as presently constructed it isn't necessary, but because it's security-related I include it for completeness.} As with \kode{log\_in} and associated methods, we'll put the resulting \kode{log\_out} method in the Sessions helper module, as shown in Listing~\ref{code:log_out_method}.
% \footnote{Manipulating the \kode{@current\_user} variable directly as in Listing~\ref{code:destroy_session} is a little unclean, and in general it would be preferable to define a \emph{setter method} in the Sessions helper called \kode{current\_user=} to allow code like \kode{self.current\_user = nil}. In this case, though, the line doesn't even matter due to the immediate redirect, and setter methods are potentially confusing, so including it here seems like overkill. (Plus, what is \kode{self} doing in that assignment? The answer is that it refers to the \emph{controller itself}, and is necessary to prevent the creation of a \emph{local} variable called \kode{current\_user}. Like I said: \emph{overkill}.)}

\begin{codelisting}
\label{code:log_out_method}
\codecaption{The \kode{log\_out} method. \\ \filepath{app/helpers/sessions\_helper.rb}}
%= lang:ruby, options: "hl_lines": [12, 13]
\begin{code}
module SessionsHelper

  # Logs in the given user.
  def log_in(user)
    session[:user_id] = user.id
  end
  .
  .
  .
  # Logs out the current user.
  def log_out
    session.delete(:user_id)
    @current_user = nil
  end
end
\end{code}
\end{codelisting}

We can put the \kode{log\_out} method to use in the Sessions controller's \kode{de\-stroy} action, as shown in Listing~\ref{code:destroy_session}.

\begin{codelisting}
\label{code:destroy_session}
\codecaption{Destroying a session (user logout). \\ \filepath{app/controllers/sessions\_controller.rb}}
%= lang:ruby, options: "hl_lines": [18, 19]
\begin{code}
class SessionsController < ApplicationController

  def new
  end

  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      log_in user
      redirect_to user
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end

  def destroy
    log_out
    redirect_to root_url
  end
end
\end{code}
\end{codelisting}

To test the logout machinery, we can add some steps to the user login test from Listing~\ref{code:user_login_test_valid_information}. After logging in, we use \kode{delete} to issue a \texttt{DELETE} request to the logout path (Table~\ref{table:RESTful_sessions}) and verify that the user is logged out and redirected to the root URL. We also check that the login link reappears and that the logout and profile links disappear. The new steps appear in Listing~\ref{code:user_logout_test}.

\begin{codelisting}
\label{code:user_logout_test}
\codecaption{A test for user logout. \passing \\ \filepath{test/integration/users\_login\_test.rb}}
%= lang:ruby, options: "hl_lines": [7, 10, 17, 18, 19, 20, 21, 22, 23]
\begin{code}
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest
  .
  .
  .
  test "login with valid information followed by logout" do
    get login_path
    post login_path, session: { email: @user.email, password: 'password' }
    assert is_logged_in?
    assert_redirected_to @user
    follow_redirect!
    assert_template 'users/show'
    assert_select "a[href=?]", login_path, count: 0
    assert_select "a[href=?]", logout_path
    assert_select "a[href=?]", user_path(@user)
    delete logout_path
    assert_not is_logged_in?
    assert_redirected_to root_url
    follow_redirect!
    assert_select "a[href=?]", login_path
    assert_select "a[href=?]", logout_path,      count: 0
    assert_select "a[href=?]", user_path(@user), count: 0
  end
end
\end{code}
\end{codelisting}

\noindent (Now that we have \kode{is\_logged\_in?}\ available in tests, we've also thrown in a bonus \kode{assert is\_logged\_in?}\ immediately after posting valid information to the sessions path.)

With the session \kode{destroy} action thus defined and tested, the initial  sign\-up/\-login/\-logout triumvirate is complete, and the test suite should be \passing:

\begin{codelisting}
\codecaption{\passing}
%= lang:text
\begin{code}
$ bundle exec rake test
\end{code}
\end{codelisting}

\section{Remember me} % (fold)
\label{sec:remember_me}

The login system we finished in Section~\ref{sec:logging_in} is self-contained and fully functional, but most websites have the additional capability of remembering users' sessions even after they close their browsers. In this section, we'll start by remembering user logins by default, expiring their sessions only when they explicitly log out. In Section~\ref{sec:remember_me_checkbox}, we'll enable a common alternative model, a ``remember me'' checkbox that allows users to opt out of being remembered. Both of these models are professional-grade, with the first used by sites such as \href{http://github.com/}{GitHub} and \href{http://bitbucket.org/}{Bitbucket}, and the second used by sites such as \href{http://www.facebook.com/}{Facebook} and \href{http://twitter.com/}{Twitter}.

    \subsection{Remember token and digest} % (fold)
    \label{sec:remember_token}

In Section~\ref{sec:logging_in}, we used the Rails \kode{session} method to store the user's id, but this information disappears when the user closes their browser. In this section, we'll take the first step toward persistent sessions by generating a \emph{remember token} appropriate for creating permanent cookies using the \kode{cookies} method, together with a secure \emph{remember digest} for authenticating those tokens.

As noted in Section~\ref{sec:a_working_log_in_method}, information stored using \kode{session} is automatically secure, but this is not the case with information stored using \kode{cookies}. In particular, persistent cookies are vulnerable to \href{http://en.wikipedia.org/wiki/Session_hijacking}{session hijacking}, in which an attacker uses a stolen remember token to log in as a particular user. There are four main ways to steal cookies: (1) using a \href{https://en.wikipedia.org/wiki/Packet_analyzer}{packet sniffer} to detect cookies being passed over insecure networks,\footnote{Session hijacking was widely publicized by the \href{http://codebutler.com/firesheep}{Firesheep} application, which showed that remember tokens at many high-profile sites were visible when connected to public Wi-Fi networks.} (2) compromising a database containing remember tokens, (3) using \href{http://en.wikipedia.org/wiki/Cross-site_scripting}{cross-site scripting (XSS)}, and (4) gaining physical access to a machine with a logged-in user. We prevented the first problem in Section~\ref{sec:professional_grade_deployment} by using \href{https://en.wikipedia.org/wiki/Transport_Layer_Security}{Secure Sockets Layer} (SSL) site-wide, which protects network data from packet sniffers. We'll prevent the second problem by storing a hash digest of the remember token instead of the token itself, in much the same way that we stored password digests instead of raw passwords in Section~\ref{sec:adding_a_secure_password}. Rails automatically prevents the third problem by escaping any content inserted into view templates. Finally, although there's no iron-clad way to stop attackers who have physical access to a logged-in computer, we'll minimize the fourth problem by changing tokens every time a user logs out and by taking care to \emph{cryptographically sign} any potentially sensitive information we place on the browser.

With these design and security considerations in mind, our plan for creating persistent sessions appears as follows:

\begin{enumerate}
\item Create a random string of digits for use as a remember token.
\item Place the token in the browser cookies with an expiration date far in the future.
\item Save the hash digest of the token to the database.
\item Place an encrypted version of the user's id in the browser cookies.
\item When presented with a cookie containing a persistent user id, find the user in the database using the given id, and verify that the remember token cookie matches the associated hash digest from the database.
\end{enumerate}

\noindent Note how similar the final step is to logging a user in, where we retrieve the user by email address and then verify (using the \kode{authenticate} method) that the submitted password matches the password digest (Listing~\ref{code:find_authenticate_user}). As a result, our implementation will parallel aspects of \kode{has\_secure\_password}.

We'll start by adding the required \kode{remember\_digest} attribute to the User model, as shown in Figure~\ref{fig:user_model_remember_digest}.

\begin{figure}
\begin{center}
\includegraphics{images/figures/user_model_remember_digest.pdf}
\end{center}
\caption{The User model with an added \kode{remember\_digest} attribute.\label{fig:user_model_remember_digest}}
\end{figure}

\noindent To add the data model from Figure~\ref{fig:user_model_remember_digest} to our application, we'll generate a migration:

%= lang:console
\begin{code}
$ rails generate migration add_remember_digest_to_users remember_digest:string
\end{code}

\noindent (Compare to the password digest migration in Section~\ref{sec:a_hashed_password}.) As in previous migrations, we've used a migration name that ends in \kode{\_to\_users} to tell Rails that the migration is designed to alter the \kode{users} table in the database. Because we also included the attribute (\kode{remember\_digest}) and type (\kode{string}), Rails generates a default migration for us, as shown in Listing~\ref{code:add_remember_digest_to_users_generated}.

\begin{codelisting}
\label{code:add_remember_digest_to_users_generated}
\codecaption{The generated migration for the remember digest. \\ \filepath{db/migrate/[timestamp]\_add\_remember\_digest\_to\_users.rb}}
%= lang:ruby
\begin{code}
class AddRememberDigestToUsers < ActiveRecord::Migration
  def change
    add_column :users, :remember_digest, :string
  end
end
\end{code}
\end{codelisting}

Because we don't expect to retrieve users by remember digest, there's no need to put an index on the \kode{remember\_digest} column, and we can use the default migration as generated above:

%= lang:text
\begin{code}
$ bundle exec rake db:migrate
\end{code}

Now we have to decide what to use as a remember token. There are many mostly equivalent possibilities---essentially, any long random string will do. The \kode{urlsafe\_base64} method from the \kode{SecureRandom} module in the Ruby standard library fits the bill:\footnote{This choice is based on the \href{http://railscasts.com/episodes/274-remember-me-reset-password}{RailsCast on remember me}.} it returns a random string of length 22 composed of the characters A--Z, a--z, 0--9, ``-'', and ``\_'' (for a total of 64 possibilities, thus ``\href{http://en.wikipedia.org/wiki/Base64}{base64}''). A typical base64 string appears as follows:

%= lang:console
\begin{code}
$ rails console
>> SecureRandom.urlsafe_base64
=> "q5lt38hQDc_959PVoo6b7A"
\end{code}

Just as it's perfectly fine if two users have the same password,\footnote{Indeed, it had better be OK, because with bcrypt's \href{https://en.wikipedia.org/wiki/Salt_%28cryptography%29}{salted hashes} there's no way for us to tell if two users' passwords match.} there's no need for remember tokens to be unique, but it's more secure if they are.\footnote{With unique remember tokens, an attacker always needs \emph{both} the user id and the remember token cookies to hijack the session.} In the case of the base64 string above, each of the 22 characters has 64 possibilities, so the probability of two remember tokens colliding is a negligibly small $1/64^{22} = 2^{-132} \approx 10^{-40}$. As a bonus, by using base64 strings specifically designed to be safe in URLs (as indicated by the name \kode{urlsafe\_base64}), we'll be able to use the same token generator to make account activation and password reset links in Chapter~\ref{cha:account_activation_and_password_reset}.

Remembering users involves creating a remember token and saving the digest of the token to the database. We've already defined a \kode{digest} method for use in the test fixtures (Listing~\ref{code:digest_method}), and we can use the results of the discussion above to create a \kode{new\_token} method to create a new token. As with \kode{digest}, the new token method doesn't need a user object, so we'll make it a class method.\footnote{As a general rule, if a method doesn't need an instance of an object, it should be a class method. Indeed, this decision will prove important in Section~\ref{sec:account_activation_mailer}.} The result is the User model shown in Listing~\ref{code:token_method}.

\begin{codelisting}
\label{code:token_method}
\codecaption{Adding a method for generating tokens. \\ \filepath{app/models/user.rb}}
%= lang:ruby, options: "hl_lines": [20]
\begin{code}
class User < ActiveRecord::Base
  before_save { self.email = email.downcase }
  validates :name,  presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, length: { minimum: 6 }

  # Returns the hash digest of the given string.
  def User.digest(string)
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                  BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
  end

  # Returns a random token.
  def User.new_token
    SecureRandom.urlsafe_base64
  end
end
\end{code}
\end{codelisting}

Our plan for the implementation is to make a \kode{user.remember} method that associates a remember token with the user and saves the corresponding remember digest to the database. Because of the migration in Listing~\ref{code:add_remember_digest_to_users_generated}, the User model already has a \kode{remember\_digest} attribute, but it doesn't yet have a \kode{remember\_token} attribute. We need a way to make a token available via \kode{user.remember\_token} (for storage in the cookies) \emph{without} storing it in the database. We solved a similar issue with secure passwords in Section~\ref{sec:adding_a_secure_password}, which paired a virtual \kode{password} attribute with a secure \kode{password\_digest} attribute in the database. In that case, the virtual \kode{password} attribute was created automatically by \kode{has\_secure\_password}, but we'll have to write the code for a \kode{remember\_token} ourselves. The way to do this is to use \kode{attr\_accessor} to create an accessible attribute, which we saw before in Section~\ref{sec:a_user_class}:

%= lang:ruby, options: "hl_lines": [2, 7, 8]
\begin{code}
class User < ActiveRecord::Base
  attr_accessor :remember_token
  .
  .
  .
  def remember
    self.remember_token = ...
    update_attribute(:remember_digest, ...)
  end
end
\end{code}

\noindent Note the form of the assignment in the first line of the \kode{remember} method. Because of the way Ruby handles assignments inside objects, without \kode{self} the assignment would create a \emph{local} variable called \kode{remember\_token}, which isn't what we want. Using \kode{self} ensures that assignment sets the user's \kode{remem\-ber\_\-token} attribute. (Now you know why the \kode{before\_save} callback from Listing~\ref{code:email_downcase} uses \kode{self.email} instead of just \kode{email}.) Meanwhile, the second line of \kode{remember} uses the \kode{update\_attribute} method to update the remember digest. (As noted in Section~\ref{sec:updating_user_objects}, this method bypasses the validations, which is necessary in this case because we don't have access to the user's password or confirmation.)

With these considerations in mind, we can create a valid token and associated digest by first making a new remember token using \kode{User.new\_\-token}, and then updating the remember digest with the result of applying \kode{User.\-digest}. This procedure gives the \kode{remember} method shown in Listing~\ref{code:user_model_remember}.

\begin{codelisting}
\label{code:user_model_remember}
\codecaption{Adding a \kode{remember} method to the User model. \passing \\ \filepath{app/models/user.rb}}
%= lang:ruby, options: "hl_lines": [2, 26, 27]
\begin{code}
class User < ActiveRecord::Base
  attr_accessor :remember_token
  before_save { self.email = email.downcase }
  validates :name,  presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, length: { minimum: 6 }

  # Returns the hash digest of the given string.
  def User.digest(string)
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                  BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
  end

  # Returns a random token.
  def User.new_token
    SecureRandom.urlsafe_base64
  end

  # Remembers a user in the database for use in persistent sessions.
  def remember
    self.remember_token = User.new_token
    update_attribute(:remember_digest, User.digest(remember_token))
  end
end
\end{code}
\end{codelisting}

\subsection{Login with remembering} % (fold)
\label{sec:login_with_remembering}

Having created a working \kode{user.remember} method, we're now in a position to create a persistent session by storing a user's (encrypted) id and remember token as permanent cookies on the browser. The way to do this is with the \kode{cookies} method, which (as with \kode{session}) we can treat as a hash. A cookie consists of two pieces of information, a \kode{value} and an optional \kode{expires} date. For example, we could make a persistent session by creating a cookie with value equal to the remember token that expires 20~years from now:

%= lang:ruby
\begin{code}
cookies[:remember_token] = { value:   remember_token,
                             expires: 20.years.from_now.utc }
\end{code}

\noindent (This uses one of the convenient Rails time helpers, as discussed in Box~\ref{aside:time_helpers}.) This pattern of setting a cookie that expires 20 years in the future is so common that Rails has a special \kode{permanent} method to implement it, so that we can simply write

%= lang:ruby
\begin{code}
cookies.permanent[:remember_token] = remember_token
\end{code}

\noindent This causes Rails to set the expiration to \kode{20.\-years.\-from\_now} automatically.

\begin{aside}
\label{aside:time_helpers}
\heading{Cookies expire \texttt{20.years.from\_now}}

You may recall from Section~\ref{sec:a_class_of_our_own} that Ruby lets you add methods to \emph{any} class, even built-in ones. In that section, we added a \texttt{palindrome?}\ method to the \texttt{String} class (and discovered as a result that \texttt{"deified"} is a palindrome), and we also saw how Rails adds a \texttt{blank?}\ method to class \texttt{Object} (so that \texttt{"".blank?}, \texttt{"~".blank?}, and \texttt{nil.blank?}\ are all \texttt{true}). The \texttt{cookies.permanent} method, which creates ``permanent'' cookies with an expiration \texttt{20.years.from\_now}, gives yet another example of this practice through one of Rails' \emph{time helpers}, which are methods added to \texttt{Fixnum} (the base class for integers):

\begin{verbatim}
  $ rails console
  >> 1.year.from_now
  => Sun, 09 Aug 2015 16:48:17 UTC +00:00
  >> 10.weeks.ago
  => Sat, 31 May 2014 16:48:45 UTC +00:00
\end{verbatim}

\noindent Rails adds other helpers, too:

\begin{verbatim}
  >> 1.kilobyte
  => 1024
  >> 5.megabytes
  => 5242880
\end{verbatim}

\noindent These are useful for upload validations, making it easy to restrict, say, image uploads to \texttt{5.megabytes}.

Although it should be used with caution, the flexibility to add methods to built-in classes allows for extraordinarily natural additions to plain Ruby. Indeed, much of the elegance of Rails ultimately derives from the malleability of the underlying Ruby language.

\end{aside}

To store the user's id in the cookies, we could follow the pattern used with the \kode{session} method (Listing~\ref{code:log_in_function}) using something like

%= lang:ruby
\begin{code}
cookies[:user_id] = user.id
\end{code}

\noindent Because it places the id as plain text, this method exposes the form of the application's cookies and makes it easier for an attacker to compromise user accounts. To avoid this problem, we'll use a \emph{signed} cookie, which securely encrypts the cookie before placing it on the browser:

%= lang:ruby
\begin{code}
cookies.signed[:user_id] = user.id
\end{code}

\noindent Because we want the user id to be paired with the permanent remember token, we should make it permanent as well, which we can do by chaining the \kode{signed} and \kode{permanent} methods:

%= lang:ruby
\begin{code}
cookies.permanent.signed[:user_id] = user.id
\end{code}

After the cookies are set, on subsequent page views we can retrieve the user with code like

%= lang:ruby
\begin{code}
User.find_by(id: cookies.signed[:user_id])
\end{code}

\noindent where \kode{cookies.signed[:user\_id]} automatically decrypts the user id \linebreak cookie. We can then use bcrypt to verify that \kode{cookies[:remember\_token]} matches the \kode{remember\_digest} generated in Listing~\ref{code:user_model_remember}. (In case you're wondering why we don't just use the signed user id, without the remember token, this would allow an attacker with possession of the encrypted id to log in as the user in perpetuity. In the present design, an attacker with both cookies can log in as the user only until the user logs out.)

The final piece of the puzzle is to verify that a given remember token matches the user's remember digest, and in this context there are a couple of equivalent ways to use bcrypt to verify a match. If you look at the \href{https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb}{secure password source code}, you'll find a comparison like this:\footnote{As noted in Section~\ref{sec:a_hashed_password}, ``unencrypted password'' is a misnomer, as the secure password is \emph{hashed}, not encrypted.}

%= lang:ruby
\begin{code}
BCrypt::Password.new(password_digest) == unencrypted_password
\end{code}

\noindent In our case, the analogous code would look like this:

%= lang:ruby
\begin{code}
BCrypt::Password.new(remember_digest) == remember_token
\end{code}

\noindent If you think about it, this code is really strange: it appears to be comparing a bcrypt password digest directly with a token, which would imply \emph{decrypting} the digest in order to compare using \kode{==}. But the whole point of using bcrypt is for hashing to be irreversible, so this can't be right. Indeed, digging into the \href{https://github.com/codahale/bcrypt-ruby/blob/master/lib/bcrypt/password.rb}{source code of the bcrypt gem} verifies that the comparison operator \kode{==} is being \emph{redefined}, and under the hood the comparison above is equivalent to the following:

%= lang:ruby
\begin{code}
BCrypt::Password.new(remember_digest).is_password?(remember_token)
\end{code}

\noindent Instead of \kode{==}, this uses the boolean method \kode{is\_password?}\ to perform the comparison. Because its meaning is a little clearer, we'll prefer this second comparison form in the application code.

The above discussion suggests putting the digest--token comparison into an \kode{authenticated?}\ method in the User model, which plays a similar role to the \kode{authenticate} method provided by \kode{has\_secure\_password} for authenticating a user (Listing~\ref{code:log_in_success}). The implementation appears in Listing~\ref{code:authenticated_p}.

\begin{codelisting}
\label{code:authenticated_p}
\codecaption{Adding an \kode{authenticated?}\ method to the User model. \\ \filepath{app/models/user.rb}}
%= lang:ruby, options: "hl_lines": [32]
\begin{code}
class User < ActiveRecord::Base
  attr_accessor :remember_token
  before_save { self.email = email.downcase }
  validates :name,  presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, length: { minimum: 6 }

  # Returns the hash digest of the given string.
  def User.digest(string)
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                  BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
  end

  # Returns a random token.
  def User.new_token
    SecureRandom.urlsafe_base64
  end

  # Remembers a user in the database for use in persistent sessions.
  def remember
    self.remember_token = User.new_token
    update_attribute(:remember_digest, User.digest(remember_token))
  end

  # Returns true if the given token matches the digest.
  def authenticated?(remember_token)
    BCrypt::Password.new(remember_digest).is_password?(remember_token)
  end
end
\end{code}
\end{codelisting}

\noindent Although the \kode{authenticated?}\ method in Listing~\ref{code:authenticated_p} is tied specifically to the remember token, it will turn out to be useful in other contexts as well, and we'll generalize it in Chapter~\ref{cha:account_activation_and_password_reset}.

We're now in a position to remember a logged-in user, which we'll do by adding a \kode{remember} helper to go along with \kode{log\_in}, as shown in Listing~\ref{code:log_in_with_remember}.

\begin{codelisting}
\label{code:log_in_with_remember}
\codecaption{Logging in and remembering a user. \\ \filepath{app/controllers/sessions\_controller.rb}}
%= lang:ruby, options: "hl_lines": [10]
\begin{code}
class SessionsController < ApplicationController

  def new
  end

  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      log_in user
      remember user
      redirect_to user
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end

  def destroy
    log_out
    redirect_to root_url
  end
end
\end{code}
\end{codelisting}

\noindent As with \kode{log\_in}, Listing~\ref{code:log_in_with_remember} defers the real work to the Sessions helper, where we define a \kode{remember} method that calls \kode{user.remember}, thereby generating a remember token and saving its digest to the database. It then uses \kode{cookies} to create permanent cookies for the user id and remember token as described above. The result appears in Listing~\ref{code:remember_method}.

\begin{codelisting}
\label{code:remember_method}
\codecaption{Remembering the user. \\ \filepath{app/helpers/sessions\_helper.rb}}
%= lang:ruby, options: "hl_lines": [10, 11, 12]
\begin{code}
module SessionsHelper

  # Logs in the given user.
  def log_in(user)
    session[:user_id] = user.id
  end

  # Remembers a user in a persistent session.
  def remember(user)
    user.remember
    cookies.permanent.signed[:user_id] = user.id
    cookies.permanent[:remember_token] = user.remember_token
  end

  # Returns the current logged-in user (if any).
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in?
    !current_user.nil?
  end

  # Logs out the current user.
  def log_out
    session.delete(:user_id)
    @current_user = nil
  end
end
\end{code}
\end{codelisting}

With the code in Listing~\ref{code:remember_method}, a user logging in will be remembered in the sense that their browser will get a valid remember token, but it doesn't yet do us any good because the \kode{current\_user} method defined in Listing~\ref{code:current_user} knows only about the temporary session:

%= lang:ruby
\begin{code}
@current_user ||= User.find_by(id: session[:user_id])
\end{code}

\noindent In the case of persistent sessions, we want to retrieve the user from the temporary session if \kode{session[:user\_id]} exists, but otherwise we should look for \kode{cookies[:user\_id]} to retrieve (and log in) the user corresponding to the persistent session. We can accomplish this as follows:

%= lang:ruby
\begin{code}
if session[:user_id]
  @current_user ||= User.find_by(id: session[:user_id])
elsif cookies.signed[:user_id]
  user = User.find_by(id: cookies.signed[:user_id])
  if user && user.authenticated?(cookies[:remember_token])
    log_in user
    @current_user = user
  end
end
\end{code}

\noindent (This follows the same \kode{user \&\& user.authenticated} pattern we saw in Listing~\ref{code:find_authenticate_user}.) The code above will work, but note the repeated use of both \kode{session} and \kode{cookies}. We can eliminate this duplication as follows:

%= lang:ruby, options: "hl_lines": [1, 3]
\begin{code}
if (user_id = session[:user_id])
  @current_user ||= User.find_by(id: user_id)
elsif (user_id = cookies.signed[:user_id])
  user = User.find_by(id: user_id)
  if user && user.authenticated?(cookies[:remember_token])
    log_in user
    @current_user = user
  end
end
\end{code}

\noindent This uses the common but potentially confusing construction

%= lang:ruby
\begin{code}
if (user_id = session[:user_id])
\end{code}

\noindent Despite appearances, this is \emph{not} a comparison (which would use double-equals \kode{==}), but rather is an \emph{assignment}. If you were to read it in words, you wouldn't say ``If user id equals session of user id\ldots'', but rather something like ``If session of user id exists (while setting user id to session of user id)\ldots''.\footnote{I generally use the convention of putting such assignments in parentheses, which is a visual reminder that it's not a comparison.}

Defining the \kode{current\_user} helper as discussed above leads to the implementation shown in Listing~\ref{code:persistent_current_user}.

\begin{codelisting}
\label{code:persistent_current_user}
\codecaption{Updating \kode{current\_user} for persistent sessions. \failing \\ \filepath{app/helpers/sessions\_helper.rb}}
%= lang:ruby, options: "hl_lines": [17, 18, 19, 20, 21, 22, 23, 24, 25]
\begin{code}
module SessionsHelper

  # Logs in the given user.
  def log_in(user)
    session[:user_id] = user.id
  end

  # Remembers a user in a persistent session.
  def remember(user)
    user.remember
    cookies.permanent.signed[:user_id] = user.id
    cookies.permanent[:remember_token] = user.remember_token
  end

  # Returns the user corresponding to the remember token cookie.
  def current_user
    if (user_id = session[:user_id])
      @current_user ||= User.find_by(id: user_id)
    elsif (user_id = cookies.signed[:user_id])
      user = User.find_by(id: user_id)
      if user && user.authenticated?(cookies[:remember_token])
        log_in user
        @current_user = user
      end
    end
  end

  # Returns true if the user is logged in, false otherwise.
  def logged_in?
    !current_user.nil?
  end

  # Logs out the current user.
  def log_out
    session.delete(:user_id)
    @current_user = nil
  end
end
\end{code}
\end{codelisting}

With the code as in Listing~\ref{code:persistent_current_user}, newly logged in users are correctly remembered, as you can verify by logging in, closing the browser, and checking that you're still logged in when you restart the sample application and revisit the sample application. If you want, you can even inspect the browser cookies to see the result directly (Figure~\ref{fig:cookie_in_browser}).\footnote{Google ``<your browser name> inspect cookies'' to learn how to inspect the cookies on your system.}

\begin{figure}
\begin{center}
\imagebox{images/figures/cookie_in_browser_chrome.png}
\end{center}
\caption{The remember token cookie in the local browser.\label{fig:cookie_in_browser}}
\end{figure}

There's only one problem with our application as it stands: short of clearing their browser cookies (or waiting 20 years), there's no way for users to log out. This is exactly the sort of thing our test suite should catch, and indeed it should currently be \failing:

\begin{codelisting}
\codecaption{\failing}
%= lang:text
\begin{code}
$ bundle exec rake test
\end{code}
\end{codelisting}


% subsection login_with_remembering (end)

\subsection{Forgetting users} % (fold)
\label{sec:forgetting_users}

To allow users to log out, we'll define methods to forget users in analogy with the ones to remember them. The resulting \kode{user.forget} method just undoes \kode{user.remember} by updating the remember digest with \kode{nil}, as shown in Listing~\ref{code:user_model_forget}.

\begin{codelisting}
\label{code:user_model_forget}
\codecaption{Adding a \kode{forget} method to the User model. \\ \filepath{app/models/user.rb}}
%= lang:ruby, options: "hl_lines": [37]
\begin{code}
class User < ActiveRecord::Base
  attr_accessor :remember_token
  before_save { self.email = email.downcase }
  validates :name,  presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, length: { minimum: 6 }

  # Returns the hash digest of the given string.
  def User.digest(string)
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                  BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
  end

  # Returns a random token.
  def User.new_token
    SecureRandom.urlsafe_base64
  end

  # Remembers a user in the database for use in persistent sessions.
  def remember
    self.remember_token = User.new_token
    update_attribute(:remember_digest, User.digest(remember_token))
  end

  # Returns true if the given token matches the digest.
  def authenticated?(remember_token)
    BCrypt::Password.new(remember_digest).is_password?(remember_token)
  end

  # Forgets a user.
  def forget
    update_attribute(:remember_digest, nil)
  end
end
\end{code}
\end{codelisting}

With the code in Listing~\ref{code:user_model_forget}, we're now ready to forget a permanent session by adding a \kode{forget} helper and calling it from the \kode{log\_out} helper (Listing~\ref{code:log_out_with_forget}). As seen in Listing~\ref{code:log_out_with_forget}, the \kode{forget} helper calls \kode{user.forget} and then deletes the \kode{user\_id} and \kode{remember\_\-token} cookies.

\begin{codelisting}
\label{code:log_out_with_forget}
\codecaption{Logging out from a persistent session. \\ \filepath{app/helpers/sessions\_helper.rb}}
%= lang:ruby, options: "hl_lines": [12, 13, 14, 19]
\begin{code}
module SessionsHelper

  # Logs in the given user.
  def log_in(user)
    session[:user_id] = user.id
  end
  .
  .
  .
  # Forgets a persistent session.
  def forget(user)
    user.forget
    cookies.delete(:user_id)
    cookies.delete(:remember_token)
  end

  # Logs out the current user.
  def log_out
    forget(current_user)
    session.delete(:user_id)
    @current_user = nil
  end
end
\end{code}
\end{codelisting}

% subsection forgetting_users (end)

\subsection{Two subtle bugs} % (fold)
\label{sec:two_subtle_bugs}

There are two closely related subtleties left to address. The first subtlety is that, even though the ``Log out'' link appears only when logged-in, a user could potentially have multiple browser windows open to the site. If the user then logged out in one window, clicking the ``Log out'' link in a second window would result in an error due to the use of \kode{current\_user} in Listing~\ref{code:log_out_with_forget}.\footnote{Thanks to reader Paulo Célio Júnior for pointing this out.} We can avoid this by logging out only if the user is logged in.

The second subtlety is that a user could be logged in (and remembered) in multiple browsers, such as Chrome and Firefox, which causes a problem if the user logs out in one browser but not the other.\footnote{Thanks to reader Niels de Ron for pointing this out.} For example, suppose that the user logs out in Firefox, thereby setting the remember digest to \kode{nil} (via \kode{user.forget} in Listing~\ref{code:user_model_forget}). This would still work in Firefox, because the \kode{log\_out} method in Listing~\ref{code:log_out_with_forget} deletes the user's id, so the \kode{user} variable would be \kode{nil} in the \kode{current\_user} method:

%= lang:ruby, options: "hl_lines": [6]
\begin{code}
# Returns the user corresponding to the remember token cookie.
def current_user
  if (user_id = session[:user_id])
    @current_user ||= User.find_by(id: user_id)
  elsif (user_id = cookies.signed[:user_id])
    user = User.find_by(id: user_id)
    if user && user.authenticated?(cookies[:remember_token])
      log_in user
      @current_user = user
    end
  end
end
\end{code}

\noindent As a result, the expression

%= lang:ruby
\begin{code}
user && user.authenticated?(cookies[:remember_token])
\end{code}

\noindent returns \kode{false} due to short-circuit evaluation. (Because \kode{user} is \kode{nil}, which is \kode{false} in a boolean context, the second expression never gets evaluated.) In contrast, on Chrome the user id would \emph{not} be deleted, so \kode{user} would not be \kode{nil} in

%= lang:ruby
\begin{code}
user && user.authenticated?(cookies[:remember_token])
\end{code}

\noindent and the second expression would be evaluated. This means that in the \kode{auth\-en\-ti\-ca\-ted?}\ method (Listing~\ref{code:authenticated_p}), we would end up calling

%= lang:ruby
\begin{code}
def authenticated?(remember_token)
  BCrypt::Password.new(remember_digest).is_password?(remember_token)
end
\end{code}

\noindent with a \kode{remember\_digest} equal \kode{nil} remember digest, which raises an error in the call to \kode{BCrypt::Password.\-new(remember\_\-digest)}. Instead, we want \kode{authenticated?}\ to return \kode{false} in this case.

These are exactly the sorts of subtleties that benefit from test-driven development, so we'll write tests to catch the two errors before correcting them. We first get the integration test from Listing~\ref{code:user_logout_test} to \failing, as shown in Listing~\ref{code:test_double_logout}.

\begin{codelisting}
\label{code:test_double_logout}
\codecaption{A test for user logout. \failing \\ \filepath{test/integration/users\_login\_test.rb}}
%= lang:ruby, options: "hl_lines": [20, 21]
\begin{code}
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest
  .
  .
  .
  test "login with valid information followed by logout" do
    get login_path
    post login_path, session: { email: @user.email, password: 'password' }
    assert is_logged_in?
    assert_redirected_to @user
    follow_redirect!
    assert_template 'users/show'
    assert_select "a[href=?]", login_path, count: 0
    assert_select "a[href=?]", logout_path
    assert_select "a[href=?]", user_path(@user)
    delete logout_path
    assert_not is_logged_in?
    assert_redirected_to root_url
    # Simulate a user clicking logout in a second window.
    delete logout_path
    follow_redirect!
    assert_select "a[href=?]", login_path
    assert_select "a[href=?]", logout_path,      count: 0
    assert_select "a[href=?]", user_path(@user), count: 0
  end
end
\end{code}
\end{codelisting}

\noindent The second call to \kode{delete logout\_path} in Listing~\ref{code:test_double_logout} should raise an error due to the missing \kode{current\_user}, leading to a \failing\ test suite:

\begin{codelisting}
\codecaption{\failing}
%= lang:text
\begin{code}
$ bundle exec rake test
\end{code}
\end{codelisting}

The application code simply involves calling \kode{log\_out} only if \kode{logged\_\-in?}\ is true, as shown in Listing~\ref{code:destroy_forget}.

\begin{codelisting}
\label{code:destroy_forget}
\codecaption{Only logging out if logged in. \passing \\ \filepath{app/controllers/sessions\_controller.rb}}
%= lang:ruby, options: "hl_lines": [6]
\begin{code}
class SessionsController < ApplicationController
  .
  .
  .
  def destroy
    log_out if logged_in?
    redirect_to root_url
  end
end
\end{code}
\end{codelisting}

The second case, involving a scenario with two different browsers, is harder to simulate with an integration test, but it's easy to check in the User model test directly. All we need is to start with a user that has no remember digest (which is true for the \kode{@user} variable defined in the \kode{setup} method) and then call \kode{authenticated?}, as shown in Listing~\ref{code:test_authenticated_invalid_token}. (Note that we've just left the remember token blank; it doesn't matter what its value is, because the error occurs before it ever gets used.)

\begin{codelisting}
\label{code:test_authenticated_invalid_token}
\codecaption{A test of \kode{authenticated?}\ with a nonexistent digest. \failing \\ \filepath{test/models/user\_test.rb}}
%= lang:ruby
\begin{code}
require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com",
                     password: "foobar", password_confirmation: "foobar")
  end
  .
  .
  .
  test "authenticated? should return false for a user with nil digest" do
    assert_not @user.authenticated?('')
  end
end
\end{code}
\end{codelisting}

Because \kode{BCrypt::Password.new(nil)} raises an error, the test suite should now be \failing:

\begin{codelisting}
\codecaption{\failing}
%= lang:text
\begin{code}
$ bundle exec rake test
\end{code}
\end{codelisting}

To fix the error and get to \passing, all we need to do is return \kode{false} if the remember digest is \kode{nil}, as shown in Listing~\ref{code:authenticated_p_fixed}.

\begin{codelisting}
\label{code:authenticated_p_fixed}
\codecaption{Updating \kode{authenticated?}\ to handle a nonexistent digest. \passing \\ \filepath{app/models/user.rb}}
%= lang:ruby, options: "hl_lines": [7]
\begin{code}
class User < ActiveRecord::Base
  .
  .
  .
  # Returns true if the given token matches the digest.
  def authenticated?(remember_token)
    return false if remember_digest.nil?
    BCrypt::Password.new(remember_digest).is_password?(remember_token)
  end
end
\end{code}
\end{codelisting}

\noindent This uses the \kode{return} keyword to return immediately if the remember digest is \kode{nil}, which is a common way to emphasize that the rest of the method gets ignored in that case. The equivalent code

%= lang:ruby
\begin{code}
if remember_digest.nil?
  false
else
  BCrypt::Password.new(remember_digest).is_password?(remember_token)
end
\end{code}

\noindent would also work fine, but I prefer the explicitness of the version in Listing~\ref{code:authenticated_p_fixed} (which also happens to be slightly shorter).

With the code in Listing~\ref{code:authenticated_p_fixed}, our full test suite should be \passing, and both subtleties should now be addressed:

\begin{codelisting}
\codecaption{\passing}
%= lang:text
\begin{code}
$ bundle exec rake test
\end{code}
\end{codelisting}

% subsection two_subtle_bugs (end)

\subsection{``Remember me'' checkbox} % (fold)
\label{sec:remember_me_checkbox}

With the code in Section~\ref{sec:forgetting_users}, our application has a complete, professional-grade authentication system. As a final step, we'll see how to make staying logged in optional using a ``remember me'' checkbox. A mockup of the login form with such a checkbox appears in Figure~\ref{fig:login_remember_me_mockup}.

\begin{figure}
\begin{center}
\imagebox{images/figures/login_remember_me_mockup.png}
\end{center}
\caption{A mockup of a ``remember me'' checkbox.\label{fig:login_remember_me_mockup}}
\end{figure}

To write the implementation, we start by adding a checkbox to the login form from Listing~\ref{code:login_form}. As with labels, text fields, password fields, and submit buttons, checkboxes can be created with a Rails helper method. In order to get the styling right, though, we have to \emph{nest} the checkbox inside the label, as follows:

%= lang:rhtml
\begin{code}
<%= f.label :remember_me, class: "checkbox inline" do %>
  <%= f.check_box :remember_me %>
  <span>Remember me on this computer</span>
<% end %>
\end{code}

\noindent Putting this into the login form gives the code shown in Listing~\ref{code:remember_me_checkbox}.

\begin{codelisting}
\label{code:remember_me_checkbox}
\codecaption{Adding a ``remember me'' checkbox to the login form. \\ \filepath{app/views/sessions/new.html.erb}}
%= lang:rhtml, options: "hl_lines": [14, 15, 16, 17]
\begin{code}
<% provide(:title, "Log in") %>
<h1>Log in</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(:session, url: login_path) do |f| %>

      <%= f.label :email %>
      <%= f.email_field :email, class: 'form-control' %>

      <%= f.label :password %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.label :remember_me, class: "checkbox inline" do %>
        <%= f.check_box :remember_me %>
        <span>Remember me on this computer</span>
      <% end %>

      <%= f.submit "Log in", class: "btn btn-primary" %>
    <% end %>

    <p>New user? <%= link_to "Sign up now!", signup_path %></p>
  </div>
</div>
\end{code}
\end{codelisting}

In Listing~\ref{code:remember_me_checkbox}, we've included the CSS classes \kode{checkbox} and \kode{inline}, which Bootstrap uses to put the checkbox and the text (``Remember me on this computer'') in the same line. In order to complete the styling, we need just a few more CSS rules, as shown in Listing~\ref{code:remember_me_css}. The resulting login form appears in Figure~\ref{fig:login_form_remember_me}.

\begin{codelisting}
\label{code:remember_me_css}
\codecaption{CSS for the ``remember me'' checkbox. \\ \filepath{app/assets/stylesheets/custom.css.scss}}
%= lang:scss
\begin{code}
.
.
.
/* forms */
.
.
.
.checkbox {
  margin-top: -10px;
  margin-bottom: 10px;
  span {
    margin-left: 20px;
    font-weight: normal;
  }
}

#session_remember_me {
  width: auto;
  margin-left: 0;
}
\end{code}
\end{codelisting}


\begin{figure}
\begin{center}
\image{images/figures/login_form_remember_me.png}
\end{center}
\caption{The login form with an added ``remember me'' checkbox.\label{fig:login_form_remember_me}}
\end{figure}

Having edited the login form, we're now ready to remember users if they check the checkbox and forget them otherwise. Incredibly, because of all our work in the previous sections, the implementation can be reduced to one line. We start by noting that the \kode{params} hash for submitted login forms now includes a value based on the checkbox (as you can verify by submitting the form in Listing~\ref{code:remember_me_checkbox} with invalid information and inspecting the values in the debug section of the page). In particular, the value of

%= lang:ruby
\begin{code}
params[:session][:remember_me]
\end{code}

\noindent is \kode{'1'} if the box is checked and \kode{'0'} if it isn't.

By testing the relevant value of the \kode{params} hash, we can now remember or forget the user based on the value of the submission:

%= lang:ruby
\begin{code}
if params[:session][:remember_me] == '1'
  remember(user)
else
  forget(user)
end
\end{code}

\noindent As explained in Box~\ref{aside:ternary_operator}, this sort of \kode{if}-\kode{then} branching structure can be converted to one line using the \emph{ternary operator} as follows:\footnote{Before we wrote \kode{remember user} without parentheses, but when used with the ternary operator omitting them results in a syntax error.}

%= lang:ruby
\begin{code}
params[:session][:remember_me] == '1' ? remember(user) : forget(user)
\end{code}

\noindent Adding this to the Sessions controller's \kode{create} method leads to the incredibly compact code shown in Listing~\ref{code:remember_me_ternary}. (Now you're in a position to understand the code in Listing~\ref{code:digest_method}, which uses the ternary operator to define the bcrypt \kode{cost} variable.)

\newpage

\begin{codelisting}
\label{code:remember_me_ternary}
\codecaption{Handling the submission of the ``remember me'' checkbox. \\ \filepath{app/controllers/sessions\_controller.rb}}
%= lang:ruby, options: "hl_lines": [10]
\begin{code}
class SessionsController < ApplicationController

  def new
  end

  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      log_in user
      params[:session][:remember_me] == '1' ? remember(user) : forget(user)
      redirect_to user
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end

  def destroy
    log_out if logged_in?
    redirect_to root_url
  end
end
\end{code}
\end{codelisting}

\noindent With the implementation in Listing~\ref{code:remember_me_ternary}, our login system is complete, as you can verify by checking or unchecking the box in your browser.

\begin{aside}
\label{aside:ternary_operator}
\heading{10 types of people}

There's an old joke that there are 10 kinds of people in the world: those who understand binary and those who don't (10, of course, being 2 in binary). In this spirit, we can say that there are 10 kinds of people in the world: those who like the ternary operator, those who don't, and those who don't yet know about it. (If you happen to be in the third category, soon you won't be any longer.)

When you do a lot of programming, you quickly learn that one of the most common bits of control flow goes something like this:

\begin{verbatim}
  if boolean?
    do_one_thing
  else
    do_something_else
  end
\end{verbatim}

\noindent Ruby, like many other languages (including C/C++, Perl, PHP, and Java), allows you to replace this with a much more compact expression using the \emph{ternary operator} (so called because it consists of three parts):

\begin{verbatim}
  boolean? ? do_one_thing : do_something_else
\end{verbatim}

\noindent You can also use the ternary operator to replace assignment, so that

\begin{verbatim}
  if boolean?
    var = foo
  else
    var = bar
  end
\end{verbatim}

\noindent becomes

\begin{verbatim}
  var = boolean? ? foo : bar
\end{verbatim}

\noindent Finally, it's often convenient to use the ternary operator in a function's return value:

\begin{verbatim}
  def foo
    do_stuff
    boolean? ? "bar" : "baz"
  end
\end{verbatim}

\noindent Since Ruby implicitly returns the value of the last expression in a function, here the \texttt{foo} method returns \texttt{"bar"} or \texttt{"baz"} depending on whether \texttt{boolean?}\ is \texttt{true} or \texttt{false}.

\end{aside}

\subsection{Remember tests} % (fold)
\label{sec:remember_tests}

Although our ``remember me'' functionality is now working, it's important to write some tests to verify its behavior. One reason is to catch implementation errors, as discussed momentarily. Even more important, though, is that the core user persistence code is in fact completely untested at present. Fixing these issues will require some trickery, but the result will be a far more powerful test suite.

\subsubsection{Testing the ``remember me'' box} % (fold)
\label{sec:testing_the_remember_me_box}

When I originally implemented the checkbox handling in Listing~\ref{code:remember_me_ternary}, instead of the correct

%= lang:ruby
\begin{code}
params[:session][:remember_me] == '1' ? remember(user) : forget(user)
\end{code}

\noindent I actually used

%= lang:ruby
\begin{code}
params[:session][:remember_me] ? remember(user) : forget(user)
\end{code}

\noindent In this context, \kode{params[:session][:remember\_me]} is either \kode{'0'} or \kode{'1'}, both of which are \kode{true} in a boolean context, so the resulting expression is \emph{always true}, and the application acts as if the checkbox is always checked. This is exactly the kind of error a test can catch.

Because remembering users requires that they be logged in, our first step is to define a helper to log users in inside tests. In Listing~\ref{code:user_login_test_valid_information}, we logged a user in using the \kode{post} method and a valid \kode{session} hash, but it's cumbersome to do this every time. To avoid needless repetition, we'll write a helper method called \kode{log\_in\_as} to log in for us.

Our method for logging a user in depends on the type of test. Inside integration tests, we can post to the sessions path as in Listing~\ref{code:user_login_test_valid_information}, but in other tests (such as controller and model tests) this won't work, and we need to manipulate the \kode{session} method directly. As a result, \kode{log\_in\_as} should detect the kind of test being used and adjust accordingly. We can tell the difference between integration tests and other kinds of tests using Ruby's convenient \kode{defined?}\ method, which returns true if its argument is defined and false otherwise. In the present case, the \kode{post\_via\_redirect} method (seen before in Listing~\ref{code:a_test_for_valid_submission}) is available only in integration tests, so the code

%= lang:ruby
\begin{code}
defined?(post_via_redirect) ...
\end{code}

\noindent will return \kode{true} inside an integration test and false otherwise. This suggests defining an \kode{integration\_test?}\ boolean method and writing an if-then statement schematically as follows:

%= lang:ruby
\begin{code}
if integration_test?
  # Log in by posting to the sessions path
else
  # Log in using the session
end
\end{code}

\noindent Filling in the comments with code leads to the \kode{log\_in\_as} helper method shown in Listing~\ref{code:test_helper_log_in}. (This is a fairly advanced method, so you are doing well if you can read it with full comprehension.)

\begin{codelisting}
\label{code:test_helper_log_in}
\codecaption{Adding a \kode{log\_in\_as} helper. \\ \filepath{test/test\_helper.rb}}
%= lang:ruby, options: "hl_lines": [17, 30]
\begin{code}
ENV['RAILS_ENV'] ||= 'test'
.
.
.
class ActiveSupport::TestCase
  fixtures :all

  # Returns true if a test user is logged in.
  def is_logged_in?
    !session[:user_id].nil?
  end

  # Logs in a test user.
  def log_in_as(user, options = {})
    password    = options[:password]    || 'password'
    remember_me = options[:remember_me] || '1'
    if integration_test?
      post login_path, session: { email:       user.email,
                                  password:    password,
                                  remember_me: remember_me }
    else
      session[:user_id] = user.id
    end
  end

  private

    # Returns true inside an integration test.
    def integration_test?
      defined?(post_via_redirect)
    end
end
\end{code}
\end{codelisting}

\noindent Note that, for maximum flexibility, the \kode{log\_in\_as} method in Listing~\ref{code:test_helper_log_in} accepts an \kode{options} hash (as in Listing~\ref{code:gravatar_option}), with default options for the password and for the ``remember me'' checkbox set to \kode{'password'} and \kode{'1'}, respectively. In particular, because hashes return \kode{nil} for nonexistent keys, code like

%= lang:ruby
\begin{code}
remember_me = options[:remember_me] || '1'
\end{code}

\noindent evaluates to the given option if present and to the default otherwise (an application of the short-circuit evaluation described in Box~\ref{aside:or_equals}).

To verify the behavior of the ``remember me'' checkbox, we'll write two tests, one each for submitting with and without the checkbox checked. This is easy using the login helper defined in Listing~\ref{code:test_helper_log_in}, with the two cases appearing as

%= lang:ruby
\begin{code}
log_in_as(@user, remember_me: '1')
\end{code}

\noindent and

%= lang:ruby
\begin{code}
log_in_as(@user, remember_me: '0')
\end{code}

\noindent (Because \kode{'1'} is the default value of \kode{remember\_me}, we could omit the corresponding option in the first case above, but I've included it to make the parallel structure more apparent.)

After logging in, we can check if the user has been remembered by looking for the \kode{remember\_token} key in the \kode{cookies}. Ideally, we would check that the cookie's value is equal to the user's remember token, but as currently designed there's no way for the test to get access to it: the \kode{user} variable in the controller has a remember token attribute, but (because \kode{remember\_token} is virtual) the \kode{@user} variable in the test doesn't. Fixing this minor blemish is left as an exercise (Section~\ref{sec:log_in_out_exercises}), but for now we can just test to see if the relevant cookie is \kode{nil} or not.

There's one more subtlety, which is that for some reason inside tests the \kode{cookies} method doesn't work with symbols as keys, so that

%= lang:ruby
\begin{code}
cookies[:remember_token]
\end{code}

\noindent is always \kode{nil}. Luckily, \kode{cookies} \emph{does} work with string keys, so that

%= lang:ruby
\begin{code}
cookies['remember_token']
\end{code}

\noindent has the value we need. The resulting tests appear in Listing~\ref{code:remember_me_test}. (Recall from Listing~\ref{code:user_login_test_valid_information} that \kode{users(:michael)} references the fixture user from Listing~\ref{code:real_user_fixture}.)

\begin{codelisting}
\label{code:remember_me_test}
\codecaption{A test of the ``remember me'' checkbox. \passing \\ \filepath{test/integration/users\_login\_test.rb}}
%= lang:ruby, options: "hl_lines": [12, 13, 17, 18]
\begin{code}
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest

  def setup
    @user = users(:michael)
  end
  .
  .
  .
  test "login with remembering" do
    log_in_as(@user, remember_me: '1')
    assert_not_nil cookies['remember_token']
  end

  test "login without remembering" do
    log_in_as(@user, remember_me: '0')
    assert_nil cookies['remember_token']
  end
end
\end{code}
\end{codelisting}

\noindent Assuming you didn't make the same implementation mistake I did, the tests should be \passing:

\begin{codelisting}
\codecaption{\passing}
%= lang:text
\begin{code}
$ bundle exec rake test
\end{code}
\end{codelisting}

% subsubsection testing_the_remember_me_box (end)

\subsubsection{Testing the remember branch} % (fold)
\label{sec:testing_the_remember_branch}

In Section~\ref{sec:login_with_remembering}, we verified by hand that the persistent session implemented in the preceding sections is working, but in fact the relevant branch in the \kode{current\_user} method is currently completely untested. My favorite way to handle this kind of situation is to raise an exception in the suspected untested block of code: if the code isn't covered, the tests will still pass; if it is covered, the resulting error will identify the relevant test. The result in the present case appears in Listing~\ref{code:branch_raise}.

\begin{codelisting}
\label{code:branch_raise}
\codecaption{Raising an exception in an untested branch. \passing \\ \filepath{app/helpers/sessions\_helper.rb}}
%= lang:ruby, options: "hl_lines": [10]
\begin{code}
module SessionsHelper
  .
  .
  .
  # Returns the user corresponding to the remember token cookie.
  def current_user
    if (user_id = session[:user_id])
      @current_user ||= User.find_by(id: user_id)
    elsif (user_id = cookies.signed[:user_id])
      raise       # The tests still pass, so this branch is currently untested.
      user = User.find_by(id: user_id)
      if user && user.authenticated?(cookies[:remember_token])
        log_in user
        @current_user = user
      end
    end
  end
  .
  .
  .
end
\end{code}
\end{codelisting}

\noindent At this point, the tests are \passing:

\begin{codelisting}
\codecaption{\passing}
%= lang:text
\begin{code}
$ bundle exec rake test
\end{code}
\end{codelisting}

\noindent This is a problem, of course, because the code in Listing~\ref{code:branch_raise} is broken. Moreover, persistent sessions are cumbersome to check by hand, so if we ever want to refactor the \kode{current\_user} method (as we will in Chapter~\ref{cha:account_activation_and_password_reset}) it's important to test it.


Because the \kode{log\_in\_as} helper method defined in Listing~\ref{code:test_helper_log_in} automatically sets \kode{session[:user\_id]}, testing the ``remember'' branch of the \kode{cur\-rent\_user} method is difficult in an integration test. Luckily, we can bypass this restriction by testing the \kode{current\_user} method directly in a Sessions helper test, whose file we have to create:

%= lang:console
\begin{code}
$ touch test/helpers/sessions_helper_test.rb
\end{code}

\noindent The test sequence is simple:

\begin{enumerate}
\item Define a \kode{user} variable using the fixtures.
\item Call the \kode{remember} method to remember the given user.
\item Verify that \kode{current\_user} is equal to the given user.
\end{enumerate}

\noindent Because the \kode{remember} method doesn't set \kode{session[:user\_id]}, this procedure will test the desired ``remember'' branch. The result appears in Listing~\ref{code:persistent_sessions_test}.

\begin{codelisting}
\label{code:persistent_sessions_test}
\codecaption{A test for persistent sessions. \\ \filepath{test/helpers/sessions\_helper\_test.rb}}
%= lang:ruby
\begin{code}
require 'test_helper'

class SessionsHelperTest < ActionView::TestCase

  def setup
    @user = users(:michael)
    remember(@user)
  end

  test "current_user returns right user when session is nil" do
    assert_equal @user, current_user
    assert is_logged_in?
  end

  test "current_user returns nil when remember digest is wrong" do
    @user.update_attribute(:remember_digest, User.digest(User.new_token))
    assert_nil current_user
  end
end
\end{code}
\end{codelisting}

\noindent Note that we've added a second test, which checks that the current user is \kode{nil} if the user's remember digest doesn't correspond correctly to the remember token, thereby testing the \kode{authenticated?}\ expression in the nested \kode{if} statement:

%= lang:ruby
\begin{code}
if user && user.authenticated?(cookies[:remember_token])
\end{code}

The test in Listing~\ref{code:persistent_sessions_test} is \failing\ as required:

\begin{codelisting}
\codecaption{\failing}
%= lang:text
\begin{code}
$ bundle exec rake test TEST=test/helpers/sessions_helper_test.rb
\end{code}
\end{codelisting}

We can get the tests in Listing~\ref{code:persistent_sessions_test} to pass by removing the \kode{raise} and restoring the original \kode{current\_user} method, as shown in Listing~\ref{code:branch_no_raise}. (You can also verify by removing the \kode{authenticated?}\ expression in Listing~\ref{code:branch_no_raise} that the second test in Listing~\ref{code:persistent_sessions_test} fails, which confirms that it tests the right thing.)

\begin{codelisting}
\label{code:branch_no_raise}
\codecaption{Removing the raised exception. \passing \\ \filepath{app/helpers/sessions\_helper.rb}}
%= lang:ruby, options: "hl_lines": [9]
\begin{code}
module SessionsHelper
  .
  .
  .
  # Returns the user corresponding to the remember token cookie.
  def current_user
    if (user_id = session[:user_id])
      @current_user ||= User.find_by(id: user_id)
    elsif (user_id = cookies.signed[:user_id])
      user = User.find_by(id: user_id)
      if user && user.authenticated?(cookies[:remember_token])
        log_in user
        @current_user = user
      end
    end
  end
  .
  .
  .
end
\end{code}
\end{codelisting}

\noindent At this point, the test suite should be \passing:

\begin{codelisting}
\codecaption{\passing}
%= lang:text
\begin{code}
$ bundle exec rake test
\end{code}
\end{codelisting}

\noindent Now that the ``remember'' branch of \kode{current\_user} is tested, we can be confident of catching regressions without having to check by hand.

% subsubsection testing_the_remember_branch (end)

% subsection remember_tests (end)

% section remember_me (end)


  \section{Conclusion} % (fold)

We've covered a lot of ground in the last two chapters, transforming our promising but unformed application into a site capable of the full suite of signup and login behaviors. All that is needed to complete the authentication functionality is to restrict access to pages based on login status and user identity. We'll accomplish this task en route to giving users the ability to edit their information, which is the main goal of Chapter~\ref{cha:updating_showing_and_deleting_users}.

Before moving on, merge your changes back into the master branch:

%= lang:text
\begin{code}
$ bundle exec rake test
$ git add -A
$ git commit -m "Finish log in/log out"
$ git checkout master
$ git merge log-in-log-out
\end{code}

\noindent Then push up the remote repository and the production server:

%= lang:text
\begin{code}
$ bundle exec rake test
$ git push
$ git push heroku
$ heroku run rake db:migrate
\end{code}

\noindent Note that the application will briefly be in an invalid state after pushing but before the migration is finished. On a production site with significant traffic, it is a good idea to turn \href{https://devcenter.heroku.com/articles/maintenance-mode}{\emph{maintenance mode}} on before making the changes:

%= lang:text
\begin{code}
$ heroku maintenance:on
$ git push heroku
$ heroku run rake db:migrate
$ heroku maintenance:off
\end{code}

\noindent This arranges to show a standard error page during the deployment and migration. (We won't bother with this step again, but it's good to see it at least once.) For more information, see the Heroku documentation on \href{https://devcenter.heroku.com/articles/error-pages}{error pages}.

\subsection{What we learned in this chapter} % (fold)
\label{sec:log_in_out_what_we_learned_in_this_chapter}

\begin{itemize}
\item Rails can maintain state from one page to the next using both temporary and persistent cookies.
\item The login form is designed to create a new session to log a user in.
\item The \kode{flash.now} method is used for flash messages on rendered pages.
\item Test-driven development is useful when debugging by reproducing the bug in a test.
\item Using the \kode{session} method, we can securely place a user id on the browser to create a temporary session.
\item We can change features such as links on the layouts based on login status.
\item Integration tests can verify correct routes, database updates, and proper changes to the layout.
\item We associate to each user a remember token and a corresponding remember digest for use in persistent sessions.
\item Using the \kode{cookies} method, we create a persistent session by placing a permanent remember token cookie on the browser.
\item Login status is determined by the presence of a current user based on the temporary session's user id or the permanent session's unique remember token.
\item The application signs users out by deleting the session's user id and removing the permanent cookie from the browser.
\item The ternary operator is a compact way to write simple if-then statements.
\end{itemize}

% subsection what_we_learned_in_this_chapter (end)

  \section{Exercises} % (fold)
  \label{sec:log_in_out_exercises}

\input{chapters/exercises_note}
\input{chapters/exercise_topic_branches}

\begin{enumerate}

  \item In Listing~\ref{code:user_model_remember}, we defined the new token and digest class methods by explicitly prefixing them with \kode{User}. This works fine and, because they are actually \emph{called} using \kode{User.new\_token} and \kode{User.digest}, it is probably the clearest way to define them. But there are two perhaps more idiomatically correct ways to define class methods, one slightly confusing and one extremely confusing. By running the test suite, verify that the implementations in Listing~\ref{code:token_digest_self} (slightly confusing) and Listing~\ref{code:token_digest_class_self} (extremely confusing) are correct. (Note that, in the context of Listing~\ref{code:token_digest_self} and Listing~\ref{code:token_digest_class_self}, \kode{self} is the \kode{User} class, whereas the other uses of \kode{self} in the User model refer to a user object \emph{instance}. This is part of what makes them confusing.)

  \item As indicated in Section~\ref{sec:remember_tests}, as the application is currently designed there's no way to access the virtual \kode{remember\_token} attribute in the integration test in Listing~\ref{code:remember_me_test}. It is possible, though, using a special test method called \kode{assigns}. Inside a test, you can access \emph{instance} variables defined in the controller by using \kode{assigns} with the corresponding symbol. For example, if the \kode{create} action defines an \kode{@user} variable, we can access it in the test using \kode{assigns(:user)}. Right now, the Sessions controller \kode{create} action defines a normal (non-instance) variable called \kode{user}, but if we change it to an instance variable we can test that \kode{cookies} correctly contains the user's remember token. By filling in the missing elements in Listing~\ref{code:login_create_user_instance} and Listing~\ref{code:improved_remember_me_test} (indicated with question marks~\kode{?} and \kode{FILL\_IN}), complete this improved test of the ``remember me'' checkbox.

\end{enumerate}

\begin{codelisting}
\label{code:token_digest_self}
\codecaption{Defining the new token and digest methods using \kode{self}. \passing \\ \filepath{app/models/user.rb}}
%= lang:ruby, options: "hl_lines": [6, 13]
\begin{code}
class User < ActiveRecord::Base
  .
  .
  .
  # Returns the hash digest of the given string.
  def self.digest(string)
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                  BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
  end

  # Returns a random token.
  def self.new_token
    SecureRandom.urlsafe_base64
  end
  .
  .
  .
end
\end{code}
\end{codelisting}


\begin{codelisting}
\label{code:token_digest_class_self}
\codecaption{Defining the new token and digest methods using \kode{class <\!< self}. \passing \\ \filepath{app/models/user.rb}}
%= lang:ruby, options: "hl_lines": [5, 7, 14]
\begin{code}
class User < ActiveRecord::Base
  .
  .
  .
  class << self
    # Returns the hash digest of the given string.
    def digest(string)
      cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                    BCrypt::Engine.cost
      BCrypt::Password.create(string, cost: cost)
    end

    # Returns a random token.
    def new_token
      SecureRandom.urlsafe_base64
    end
  end
  .
  .
  .
\end{code}
\end{codelisting}

\begin{codelisting}
\label{code:login_create_user_instance}
\codecaption{A template for using an instance variable in the \kode{create} action. \\ \filepath{app/controllers/sessions\_controller.rb}}
%= lang:ruby, options: "hl_lines": [7, 8, 9, 10, 11]
\begin{code}
class SessionsController < ApplicationController

  def new
  end

  def create
    ?user = User.find_by(email: params[:session][:email].downcase)
    if ?user && ?user.authenticate(params[:session][:password])
      log_in ?user
      params[:session][:remember_me] == '1' ? remember(?user) : forget(?user)
      redirect_to ?user
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end

  def destroy
    log_out if logged_in?
    redirect_to root_url
  end
end
\end{code}
\end{codelisting}

\begin{codelisting}
\label{code:improved_remember_me_test}
\codecaption{A template for an improved ``remember me'' test. \passing \\ \filepath{test/integration/users\_login\_test.rb}}
%= lang:ruby, options: "hl_lines": [13]
\begin{code}
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest

  def setup
    @user = users(:michael)
  end
  .
  .
  .
  test "login with remembering" do
    log_in_as(@user, remember_me: '1')
    assert_equal assigns(:user).FILL_IN, FILL_IN
  end

  test "login without remembering" do
    log_in_as(@user, remember_me: '0')
    assert_nil cookies['remember_token']
  end
  .
  .
  .
end
\end{code}
\end{codelisting}

  % section exercises (end)

% chapter log_in_log_out (end)
