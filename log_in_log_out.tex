\chapter{로그인, 로그아웃} \label{cha:log_in_log_out} 

% (fold)
\input{장/3rd_edition_note} 

새로운 사용자들의 우리 사이트에 가입할 수 있게 되었으니 (~장\ref{cha:sign_up}), 가입한 사용자가 로그인하고 로그아웃 할 수 있도록 할 차례이다. 이번 장에서는 웹상에서 행해지는 가장 일반적인 로그인, 로그아웃에 필요한 세가지 모델을 구현할 것이다.:  사용자가 브라우저를 닫는 순간 ``forgetting'' (섹~션\ref{sec:sessions_and_failed_login}  과 섹~션\ref{sec:logging_in}), \emph{자동으로} 사용자 기억하기 (섹~션\ref{sec:remember_me}),  와\emph{선택적으로} ``remember me'' 체크박스의 선택여부에 따라 사용자를 기억하기 (섹션~\ref{sec:remember_me_checkbox}).\footnote{또다른 일반적인 모델은 세션을 특정시간이 지난 후 만료시키는 것이다. 이 기능은 중요한 기밀 정보를 다루는 은행이나 금융 거래 서비스를 제공하는 사이트에 사용된다.} 

이 장에서 구현할 인증 시스템은 인증 모델을 구현해서 사용자의 로그인 상태을 체크하고, 사용자를 식별할 수 있다. 예를 들어, 이 장에서는 사이트 헤더에 로그인/로그아웃 링크와 프로파일 링크를 추가할 것이다. \ref{cha:updating_showing_and_deleting_users}장에서 보안모델을 적용하여 오직 로그인 한 사용자만 사용자 인덱스 페이지에 접근할 수 있도록 제어하고, 자신의 프로파일 정보만을 수정할 수 있도록 할것이며, 관리자 권한을 가진 사용자만 다른 사용자를 데이터베이스에서 삭제할 수 있는 권한을 가지도록 할 것 이다. 마지막으로 \ref{cha:user_microposts}장은 로그인한 사용자를 식별하여, 이 사용자 프로파일에 결합된 마이크로 포스트를 생성하고, \ref{cha:following_users}장에서는 한 사용자가 다른 사용자를 팔로우 할 수 있는 기능을 추가할 것이다.(이를 통해서 팔로잉하고 있는 사용자의 포스팅 정보를 받을 수 있다.) 

\section{세션} \label{sec:sessions_and_failed_login} 

\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol}{HTTP} 는\href{https://en.wikipedia.org/wiki/Stateless_protocol}{\emph{stateless protocol}}, 각각의 요청을 독립된 트랜젝션으로 이전 요청의 정보를 사용할 수 없다. 이 말의 의미는 페이지와 페이지을 이동할때 사용자를 기억할 방법이 없다는 것이다.\href{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP_session_state}{within the hypertext transfer protocol}; 대신 웹 어플리케이션은 사용자가 로그인 했을때 \href{http://en.wikipedia.org/wiki/Session_(computer_science)}{\emph{세션}}을 생성하여 두 컴퓨터간에 반영구적 연결을 만든다. (클라이언트 컴퓨터에서 구동되는 브라우저와 레일즈가 구동되고 있는 웹서버). 

레일즈에서 세션을 구현하는 가장 일반적인 방법은 사용자 브라우저에 저장해 놓을 수 있는 짧은 문자열인 \href{http://en.wikipedia.org/wiki/HTTP_cookie}{\emph{쿠키}}이다. 쿠키는 하나의 페이지에서 다른 페이지로 계속 유지 되기때문에, 사용자의 아이디와 같은 정보를 저장해놓고, 데이터베이스에서 이 아이디를 이용해 사용자 객체를 검색할 수 있다. 이번 섹션과 섹션 \ref{sec:logging_in}에서는 브라우저를 닫으면 만료되는 임시 세션인 \kode{session} 메서드를 사용하고, \footnote{몇몇 브라우저는 이 세션을 복구하는 기능인 ``이어서 브라우징''기능을 제공하기도 하지만, 이 기능은 레일즈의 기능을 아니다.}과  섹션\ref{sec:remember_me}에서는 더 생명주기가 긴 레일즈의 다른 메서드인 \kode{cookies}를 살펴 볼 것이다.. 

세션을 RESTful 리소스를 만드는것은 여러모로 편리하다: 로그인 페이지는 \emph{새 세션}을 만드는 폼을 렌더링하,고 로그인 자체는 \emph{세션 생성}, 로그아웃은\emph{세션 삭제}로 매칭된다. 데이터를 유지시키기 위해 데이터 베이스를 사용하는 사용자 리소스와 달리, 세션 리소스는 쿠키를 사용하여 로그인에 관련된 쿠키기반 인증 기능을 구현하는데 사용한다. 이 섹션과 다음 섹션에서 이에 필요한 세션 컨트롤러, 로그인 폼, 여기서 사용할 각각의 액션을 작성할 것이다. 그리고 사용자 로그인 섹션을 마무리하고 세션 조작 코드를 추가할 것이다. 

이전 장에서 토픽 브랜치에 작업한 내용을 머지했다: 

%= lang:console
\begin{code} $ git checkout master $ git checkout -b log-in-log-out \end{code} 

\subsection{세션 컨트롤러} \label{sec:sessions_controller} 

% (fold)
로그인과 로그아웃 기능은 각각 세션 컨트롤러의 특정 REST 액션과 대응된다: 로그인 폼은 \kode{new} 액션(이 섹션에서 다룰), 실제 로그인 동작은 <ul>{create}액션(section \ref{sec:logging_in})으로 \texttt{POST} 요청을 보내는 것이고 , 로그 아웃은 \kode{destroy} 액션 (섹션 \ref{sec:logging_out})에 \texttt{DELETE} 요청을 보내는 것이다. (표 \ref{table:RESTful_users} HTTP 메서드와 REST의 매칭) 

먼저 세션 컨트롤러의 \kode{new} 액션을 생성한다: 

%= lang:console
\begin{code} $ rails generate controller Sessions new \end{code} 

\noindent (\kode{new} 명령은 실제로 \emph{뷰}도 같이 생성한다. 이 컨트롤러는 뷰에서 앞으로 사용하지 않을 \kode{create} 와 \kode{delete} 액션도 만들어낸다.) 섹~션\ref{sec:signup_form} 에서 등장하는 가입하기 페이지의 모델에서 처럼 새로운 세션을 만들기 위한 로그인 폼을 만들 예정이다. 목업은 표 \ref{fig:login_mockup}에 있다. 

\begin{figure} \begin{center} \imagebox{images/figures/login_mockup.png} \end{center} \caption{ 목업 로그인 폼.\label{fig:login_mockup}} \end{figure} 

자동으로 \kode{resources} 메서드로 자동으로 완벽한 RESTful 라우트 만드는 사용자 리소스와는 달리 (목록 \ref{code:users_resource}), 세션 리소스는 이름 붙여진 라우트를 사용할 것이다.  \texttt{GET} 과 \texttt{POST} 요청는 \kode{login} 라우트로 \texttt{DELETE} 요청은  \kode{logout} 라우트로 처리할 것이다. 결과는 표\ref{code:sessions_resource}와 같다. (\kode{레일즈가 생성한 컨트롤러}에 사용하지 않는 라우트를 제거할 수 있다.) 

\begin{codelisting} \label{code:sessions_resource} \codecaption{세션을 위한 표준 RESTful 액션 추가 하기. 코드\\코드\filepath{config/routes.rb}} 

%= lang:ruby, options: "hl_lines": [7, 8, 9]
\begin{code} Rails.application.routes.draw do root 'static_pages#home' get 'help' => 'static_pages#help' get 'about' => 'static_pages#about' get 'contact' => 'static_pages#contact' get 'signup' => 'users#new' get 'login' => 'sessions#new' post 'login' => 'sessions#create' delete 'logout' => 'sessions#destroy' resources :users end \end{code} \end{codelisting} 

\noindent 목록\ref{code:sessions_resource}에 정의된 URL에 대응되는 액션은 사용자의 것(표\ref{table:RESTful_users})과 비슷다하다. 표 \ref{table:RESTful_sessions}. 

\begin{table} \begin{center} \footnotesize

\begin{tabular}코드{lllll} \textbf{HTTP request} &\textbf{코드URL} &\textbf{이름 붙여진 라우트} &\textbf{코드Action} &\textbf{용도} \\\hline\texttt{GET} &/login &\kode{login\_path} &\kode{new} &새로운 세션 페이지 (login) \\\texttt{POST} &/login &\kode{login\_path} &\kode{create} &새로운 세션 생성 (login) \\\texttt{DELETE} &/logout &\kode{logout\_path} &\kode{destroy} &세션 삭제 (log out) \end{tabular} \end{center} \caption{목록\ref{code:sessions_resource}.\label{table:RESTful_sessions}으로 생성되는 실제 라우트 경로} \end{table} 

이제 몇개의 커스텀 이름 붙여진 라우트를 생성할 것이다. \kode{rake routes}: 명령으로 생성된 모든 라우트를 확인할 수 있다 

%= lang:text
\begin{code} $ bundle exec rake routes Prefix Verb URI Pattern Controller#Action root GET / static_pages#home help GET /help(.:format) static_pages#help about GET /about(.:format) static_pages#about contact GET /contact(.:format) static_pages#contact signup GET /signup(.:format) users#new login GET /login(.:format) sessions#new POST /login(.:format) sessions#create logout DELETE /logout(.:format) sessions#destroy users GET /users(.:format) users#index POST /users(.:format) users#create new_user GET /users/new(.:format) users#new edit_user GET /users/:id/edit(.:format) users#edit user GET /users/:id(.:format) users#show PATCH /users/:id(.:format) users#update PUT /users/:id(.:format) users#update DELETE /users/:id(.:format) users#destroy \end{code} 

\noindent 이 결과에 대해서 깊게 모두 이해할 필요는 없다. 그러나 이런 방식으로 라우트를 확인하는 것은 어플리케이션이 제공하는 각 액션에 대한 전반적인 정보를 제공한다.  

% subsection sessions_controller (end)
\subsection{로그인 폼} \label{sec:login_form} 

% (fold)
적절하게 컨트롤러와 컨트롤러를 정의함으로써 새로운 새션을 만드는 뷰에 로그인 폼을 제대로 서비스 할 수 있다. 그림\ref{fig:login_mockup} 와 그림\ref{fig:signup_mockup}을 비교해보면 가입하기 폼에 네개의 필드에서 두개 필드(이메일과 비밀번호만)를 제외하고 나머지는 거의 같음을 확인할 수 있다. 

그림 \ref{fig:login_failure_mockup}과 같이 사용자가 잘못된 로그인 정보를 입력했을때 에러메세지와 같이 로그인 페이지를 다시 렌더링할 것이다. 섹션 \ref{sec:signup_error_messages}에서는  에러 메세지를 표시하기 위해서 에러메세지 파셜을 사용했다. 이것은 자동으로 엑티브레코드가 에러메세지를 제공했었다. 그러나 세션은 액티브레코드 객체가 아니기 때문에 에러메세지 생성을 사용할 수 없다. 그래서 세션을 위해서 에러를 플래시에 표시할 것이다. 

\begin{figure} \begin{center} \imagebox{images/figures/login_failure_mockup.png} \end{center} \caption{로그인 실패 목업.\label{fig:login_failure_mockup}} \end{figure} 

목록~\ref{code:signup_form}에서 사용한 \kode{form\_for} 헬퍼를 상기 해보자. 사용자 인스턴스 변수\kode{@user}를 인자로 사용했었다: 

%= lang:rhtml
\begin{code} < . 코드. 코드. < \end{code} 

%= form_for(@user) do |f| %>% end %>
\noindent 세션 폼과 가입하기 폼의 가장 큰 차이점은 \kode{@user} 변수와 같은 세션 모델이 없다는 것이다. 즉 다시 말해서 세션 폼을 만들때 사용하는 메서드인 \kode{form\_for} 를 사용할 때 좀 더 많은 정보를 제공해줘야한다.  

%= lang:ruby
\begin{code} form_for(@user) \end{code} 

\noindent 레일즈에서는 폼의 \kode{액션}은 POST메서드로 /user URL로 보내야 한다. 그러나 세션의 경우 먼저 리소스의 이름과 이에 맞는 URL을 \kode{form\_for}의 파라미터도 줘야한다. 이것은 레일즈의 관습적으로 더 옳다. 그러나 가입 폼에서는 일반적이지 않은 방법이다. 다만 이 단계에서는 병렬적 구조를 강조하고 싶다.} 

%= lang:ruby
\begin{code} form_for(:session, url: login_path) \end{code} 

\kode{form\_for} 구문이 완성되었으니 가입 폼(목록 \ref{code:signup_form})을 응용하여 그림 \ref{fig:login_mockup}에 대응 되는 목록 \ref{code:login_form}을 만드는 것은 간단하다. 

\begin{codelisting} \label{code:login_form} \codecaption{로그인 폼 코드. 코드\\\filepath{app/views/sessions/new.html.erb}} 

%= lang:rhtml
\begin{code} < <h1>로그인</h1> 

% provide(:title, "Log in") %>
<div class="row"> <div class="col-md-6 col-md-offset-3"> < 

%= form_for(:session, url: login_path) do |f| %>
< < 

%= f.label :email %>%= f.email_field :email, class: 'form-control' %>
< < 

%= f.label :password %>%= f.password_field :password, class: 'form-control' %>
< < 

%= f.submit "Log in", class: "btn btn-primary" %>% end %>
<p>새로운 사용자이신가요?< </div> </div> \end{code} \end{codelisting} 

%= link_to "Sign up now!", signup_path %></p>
\noindent 편리성을 위해 가입하기 링크를 넣어 주었다. 목록~\ref{code:login_form}로 만들어 지는 로그인 폼은 그림 \ref{fig:login_form}이 만들어진다. (아직 ``로그인'' 네비게이션 링크를 넣지 않았기 때문에 이 페이지에 접속하기 위해서는 주소창에 직접 /login URL을 직접 적어줘야한다. 이 부분은 섹션 \ref{sec:changing_the_layout_links}에서 작업할 예정이다.) 

\begin{figure} \begin{center} \image{images/figures/login_form.png} \end{center} \caption{로그인 .폼\label{fig:login_form}} \end{figure} 

생성된 폼의 HTML은 목록 \ref{code:login_form_html}과 같다. 

\begin{codelisting} \label{code:login_form_html} \codecaption{목록 \ref{code:login_form}이 생성한 로그인 폼 HTML.} 

%= lang:html
\begin{code} <form accept-charset="UTF-8" action="/login" method="post"> <input name="utf8" type="hidden" value="&#x2713;" /> <input name="authenticity_token" type="hidden" value="NNb6+J/j46LcrgYUC60wQ2titMuJQ5lLqyAbnbAUkdo=" /> <label for="session_email">Email</label> <input class="form-control" id="session_email" name="session[email]" type="text" /> <label for="session_password">Password</label> <input id="session_password" name="session[password]" type="password" /> <input class="btn btn-primary" name="commit" type="submit" value="Log in" /> </form> \end{code} \end{codelisting} 

\noindent 목록\ref{code:login_form_html} 과 목록\ref{code:signup_form_html}을 비교해 봤을때, 이 폼을 서브밋 했을때 \kode{params} 해시는 값은 이메일과 비밀번호 필드에 맞춰 \kode{params[:ses\-sion]\-[:email]} and \kode{params[:ses\-sion]\-[:password]}이 될것을 짐작 할 수 있을 것이다. 

% subsection login_form (end)
\subsection{사용자를 찾고 인증하기} \label{sec:finding_and_authenticating_a_user} 

% (fold)
사용자 생성(가입하기)할 때와 마찬가지로 세션을 만드는 첫번째 단계는 \emph{잘못된}먼저 폼이 서브밋 됐을때 상황부터 살펴본 후, 로그인이 실패했을때 그 원인을 제대로 표시해줄 적절한 에러메세지을 표시할 것이다.(목업 그림\ref{fig:login_failure_mockup}) 그리고 서브밋 된 이메일/비밀번호 조합이 유효한 지 여부를 확인한 후, 로그인 성공(섹션\ref{sec:logging_in})을 구현할 것이다.  

최소한의 컨트롤럭 액션인 \kode{create}와 더불어 비어있는 \kode{new}과 \kode{destroy} 액션을 만들어보자.(Listing~\ref{code:initial_create_session}). 목록 \ref{code:initial_create_session}의 \kode{create} 액션은 \kode{new} 뷰을 렌더링 해주는 역할만 하지만 지금 단계에서는 충분하다. \href{http://localhost:3000/sessions/new}{/sessions/new} 폼을 서브밋하면 그림 \ref{fig:initial_failed_login_rails_3}와 같은 화면이 렌더링 된다. 

\begin{codelisting} \label{code:initial_create_session} \codecaption{초기 버전의 세션 \kode{create} 액션. 코드\\\filepath{app/controllers/sessions\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [7]
\begin{code} class SessionsController < ApplicationController 

def new end 

def create render 'new' end 

코드def destroy end end \end{code} \end{codelisting} 

\begin{figure} \begin{center} \image{images/figures/initial_failed_login_3rd_edition.png} \end{center} \caption{목록\ref{code:initial_create_session}.\label{fig:initial_failed_login_rails_3}으로 생성된 초기 로그인 실패 화면 \kode{create} } \end{figure} 

그림 \ref{fig:initial_failed_login_rails_3}을 자세히 살펴보면 섹션 \ref{sec:login_form} 마지막에  잠깐 언급했듯이 서브밋의 결과로 \kode{params} 해시에 이메일과 비밀번호가 \kode{session}이라는 키워드로 다음과 같이 저장되어 있음을 알 수 있다: (레일즈 내부에서 이 부분을 처리해주는 이 부분은 크게 중요하지 않으므로 설명을 생략한다.) 

%= lang:yaml
\begin{code} --- session: email: 'user@example.com' password: 'foobar' commit: Log in action: create controller: sessions \end{code} 

\noindent 가입하기 폼의 경우(그림 \ref{fig:signup_failure}), 이 매개변수는 목록\ref{code:nested_hashes}을 보듯이 \emph{중첩된} 해시로 되어 있다다시 말해서, \kode{params} 는 폼의 중첩된 해시값이 담긴다. 

%= lang:ruby
\begin{code} { session: { password: "foobar", email: "user@example.com" } } \end{code} 

\noindent 이것을 다음을 의미한다. 

%= lang:ruby
\begin{code} params[:session] \end{code} 

\noindent 은 이 자체로 해시: 

%= lang:ruby
\begin{code} { password: "foobar", email: "user@example.com" } \end{code} 

\noindent 결론적으로, 

%= lang:ruby
\begin{code} params[:session][:email] \end{code} 

\noindent 은 서밋된 이메일 주소이고 

%= lang:ruby
\begin{code} params[:session][:password] \end{code} 

\noindent 은 서밋된 비밀번호이다. 

다시 말하면 \kode{create} 액션내에 \kode{params}는 이메일과 비밀번호를 이용한 인증에 필요한 모든 정보를 담고 있다. 이를 처리하기 위한 메서드도 준비되어 있다: 액티브 레코드의 \kode{User.find\_by} 메서드(섹션 \ref{sec:finding_user_objects})와 \kode{has\_secure\_password} (섹션~\ref{sec:creating_and_authenticating_a_user})가 제공하는 \kode{authenticate} 메서드. \kode{auth\-en\-ti\-cate}는 잘못된 인증 요청에 \kode{false}를 반환한다. (섹션 \ref{sec:creating_and_authenticating_a_user}), 사용자 로그인에 사용할 방법이 목록~\ref{code:find_authenticate_user}에 정리하였다. 

\begin{codelisting} \label{code:find_authenticate_user} \codecaption{사용자를 찾고, 인증하기. 코드\\\filepath{app/controllers/sessions\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [7, 8]
\begin{code} class SessionsController < ApplicationController 

def new end 

def create user = User.find_by(email: params[:session][:email].downcase) if user &&user.authenticate(params[:session][:password]) # Log the user in and redirect to the user's show page. else # Create an error message. render 'new' end end 

코드def destroy end end \end{code} \end{codelisting} 

\noindent 목록 \ref{code:find_authenticate_user}에서 처음에 강조된 라인은 데이터베이스에서 서밋된 이메일을 가지고 조회한다. (섹션~\ref{sec:uniqueness_validation}에서 처리했듯이 모든 이메일 주소를 소문자로 변환되어 저장된다. 따라서 여기서도 \kode{downcase} 메서드를 이용하여 서밋된 이메일주소를 조회해야한다.) 그 다음 라인은 약간 혼란스러울 수 있지만, 레일즈 관습상 일반적인 방법이다: 

%= lang:ruby
\begin{code} user &&user.authenticate(params[:session][:password]) \end{code} 

\noindent 이 라인에서는 \kode{\&\&} (논리적 \emph{and})를 사용자 유효성 검사에 사용하였다. 논리 연산에서 \kode{nil} 과\kode{false}를 제외한 모든 객체는 \kode{true}로 인식된다. (섹션\ref{sec:objects_and_message_passing}), 이 연산에서 있을 수 있는 경우는 다음 표\ref{table:user_and_and}와 같다. 표 \ref{table:user_and_and}을 살펴 보면, 정확히 우리가 원하는 데로 \kode{if}문의 판정결과는 오직 사용자가 입력한 이메일과 비밀번호가 데이터베이스에 존재할 때만 \kode{true}로 판정된다.  

\begin{table} \begin{center} \footnotesize

\begin{tabular}{lllll} \textbf{사용자} &\textbf{비밀번호} &\textbf{a \&\& b} \\\hline존재하지 않음 &\emph{아무값} &\kode{(nil \&\& [anything]) == false} \\유요한 사용자 &잘못된 비밀번호 &\kode{(true \&\& false) == false} \\유요한 사용자 &유효한 비밀번호 &\kode{(true \&\& true) == true} \end{tabular} \end{center} \caption{Possible results of \kode{user \&\& user.authenticate(\ldots)}.\label{table:user_and_and}} \end{table} 

% subsection finding_and_authenticating_a_user (end)
\subsection{플래시 메세지 렌더링} \label{sec:rendering_with_a_flash_message} 

% (fold)
섹션~\ref{sec:signup_error_messages}에서 가입 에러메세지는 User모델의 에러의 메세지를 이용했었다. 이 에러들은 특정 액티브레코드 객체에 연관이 있다. 따라서 세션 객체는 액티브레코드 모델이 아니므로 이 방법은 사용하지 못한다. 대신, 로그인이 실패했을때 메세지를 플래시에 넣어야 한다. 먼저, 조금 잘못된 방법을 목록 \ref{code:failed_login_attempt}에 나타내었다. 

\begin{codelisting} \label{code:failed_login_attempt} \codecaption{(실패하는) 로그인 실패 처리. 코드\\\filepath{app/controllers/sessions\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [11]
\begin{code} class SessionsController < ApplicationController 

def new end 

def create user = User.find_by(email: params[:session][:email].downcase) if user &&user.authenticate(params[:session][:password]) # Log the user in and redirect to the user's show page. else flash[:danger] = 'Invalid email/password combination' # Not quite right! render 'new' end end 

코드def destroy end end \end{code} \end{codelisting} 

\noindent 플래시 메세지는 사이트의 레이아웃에 표시되기 때문에(목록\ref{code:layout_flash}), \kode{flash\-[:danger]} 메세지는 자동으로 화면에 보여지게 된다. 이것은 Bootstrap의 CSS가 자동으로 스타일을 적용시켜준다. (그림~\ref{fig:failed_login_flash}). 

\begin{figure} \begin{center} \image{images/figures/failed_login_flash_3rd_edition.png} \end{center} \caption{로그인 실패 플래시 메세지.\label{fig:failed_login_flash}} \end{figure} 

안타깝게도 목록 \ref{code:failed_login_attempt}에 주석에 적은 데로 이 방법은 옳지 않다. 페이지는 괜찮아 보이는데 무엇이 잘못된 것일까?플래시의 내용은 하나의 \emph{요청}에 따라 유지된다. 그러나 리다이렉트와는 다르게 목록 \ref{code:signup_flash}에서 사용한 템플릿의 재 렌더링에 사용한 \kode{render}는 하나의 요청으로 간주 되지 않는다. 결국 플래시 메세지는 우리가 원하는 것보다 더 길게 하나의 요청에 대해서 유지되게 된다. 예를 들어 유효하지 않은 로그인 시도후, 홈링크를 클릭하면 플래시가 두번째로 다시 보여지게 된다.(그림 \ref{fig:flash_persistence}). 섹션 \ref{sec:a_flash_test}에서 해야하는 일이 바로 이 부분을 고치는 것이다. 

\begin{figure} \begin{center} \image{images/figures/flash_persistence_3rd_edition.png} \end{center} \caption{플래시 지속 예제.\label{fig:flash_persistence}} \end{figure} 

% subsubsection rendering_with_a_flash_message (end)
\subsection{플래시 테스트} \label{sec:a_flash_test} 

% (fold)
잘못된 플래시 동작은 어플리케이션의 작은 버그이다. 테스트 지침 글상자\ref{aside:when_to_test}에 따르면, 이 상황은 같은 테스트를 작성하여 다시 이 에러가 발생하지 않게 해야한다. 더 진행하기 전에 로그인 폼 서브밋을 테스트하는 톰합 테스트를 작성해보자. 버그를 문서화 하고 재발을 방지하는 것 말고도 이 테스트는 추후 로그인과 로그아웃 통합 테스트을 작성하는데 좋은 토대를 제공해 줄 것이다. 

어플리케이션의 로그인 동작을 테스트하는 통합 테스트를 생성하자 

%= lang:console, options: "hl_lines": [1]
\begin{code} $ rails generate integration_test users_login invoke test_unit create test/integration/users_login_test.rb \end{code} 

\noindent 이 테스트는~그림\ref{fig:failed_login_flash}과 그림\ref{fig:flash_persistence}에 시퀀스를 담고 있어야한다. 기본적인 단계는 다음과 같다: 

\begin{enumerate} \item 로그인 화면에 접근한다. \item 새로운 세션 폼이 제대로 렌더링 되었는지 검증. 잘못된 \kode{params} 해시로 \itempost 로 세션 경로에 요청을 보낸다. \item세션 폼이 플래시 메세지와 같이 다시 렌더링 되는지 검증한다. appears. \item 다른 페이지에 접근한다. (예를 들어 홈 페이지). \item 플래시 메세지가 새로운 페이지에 표시되지 \emph{않는지 } 검증한다. \end{enumerate} 

\noindent 위 단계들을 구현한 테스트가 목록\ref{code:flash_persistence_test}이다. 

\newpage

\begin{codelisting} \label{code:flash_persistence_test} \codecaption{적절하지 않은 플래시 지속성 테스트. 코드\failing \\\filepath{test/integration/users\_login\_test.rb}} 

%= lang:ruby
\begin{code} 코드require 'test_helper' 

class UsersLoginTest < ActionDispatch::IntegrationTest 

test "login with invalid information" do get login_path assert_template 'sessions/new' post login_path, session: { email: "", password: "" } assert_template 'sessions/new' assert_not flash.empty?get root_path assert flash.empty?코드end end \end{code} \end{codelisting} 

목록 \ref{code:flash_persistence_test}의 테스트를 추가한 다음 로그인 테스트 결과는 \failing여야함: 

\begin{codelisting} \codecaption코드{\failing} 

%= lang:text
\begin{code} $ bundle exec rake test TEST=test/integration/users_login_test.rb \end{code} \end{codelisting} 

\noindent 이 명령어는 하나의 테스트(오직 하나) 파일을 인자 \kode{TEST}에 파일의 전체 경로를 줘서 하는 법을 확인할 수 있다. 

목록 \ref{code:flash_persistence_test}의 실패하는 테스트를 성공시키는 방법은 \kode{flash}을 렌더링 된 페이지의 보여지는 플래시 메세지를 지칭하는 특수 변수\kode{flash.now}로 바꿔쳐서 성공시킬 수 있다. \kode{flash}와 달리, \kode{flash.now}는 새로운 요청이 오자 마자 사라진다. 이 동작이 목록 \ref{code:flash_persistence_test}의 테스트가 확인하는 어플리케이션에 맞는 동작이다. 이 변경이 반영된 코드가 목록\ref{code:correct_login_failure}이다. 

\begin{codelisting} \label{code:correct_login_failure} \codecaption{수정된 로그인 실패 코드. 코드\passing \\\filepath{app/controllers/sessions\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [11]
\begin{code} class SessionsController < ApplicationController 

def new end 

def create user = User.find_by(email: params[:session][:email].downcase) if user &&user.authenticate(params[:session][:password]) # Log the user in and redirect to the user's show page. else flash.now[:danger] = 'Invalid email/password combination' render 'new' end end 

코드def destroy end end \end{code} \end{codelisting} 

이제 로그인 통합테스트와 전체 테스트 스위트를 모두 \passing이다: 

\begin{codelisting} \codecaption코드{\passing} 

%= lang:text
\begin{code} $ bundle exec rake test TEST=test/integration/users_login_test.rb $ bundle exec rake test \end{code} \end{codelisting} 

% subsection a_flash_test (end)
% section login_failure (end)
\section{로그인} \label{sec:logging_in} 

% (fold)
이제 유효하지 않은 로그인 요청을 처리할 수 있게 되었고, 다음 차례는 유효한 로그인 요청을 한 사용자를 로그인 시켜주는 것이다. 이 섹션에서는, 우선 세션 쿠키를 브라우저가 닫힐때 만료되도록 할 것이다. 섹션\ref{sec:remember_me}에서 브라우저가 닫힌 후에도 유지되도록 할 것이다. 

세션을 구현하는 과정에서는 여러 컨트롤러와 뷰들의 메서드들을 사용해야 하게 될 것이다. 섹션 \ref{sec:back_to_the_title_helper}에서 살펴 봤듯이, 루비는 여러 기능을 \emph{모둘로} 묶어 사용할 수 있다. 편리하게도, 세션 컨트롤러를 생성할때 세션 헬퍼 모듈도 같이 생성된다(섹션~\ref{sec:sessions_controller}). 게다가 이렇게 생성된 헬퍼는 자동으로 레일즈의 뷰에 인클루드 된다. 또 모든 컨트롤러의 베이스 컨트롤러(Application controller)에 인클루드 해서 모든 컨트롤러에서 사용할 수 있게 할 수 있다(목록 \ref{code:sessions_helper_include}). 

\begin{codelisting} \label{code:sessions_helper_include} \codecaption{세션 헬퍼모듈을 Application controller에 인클루드 하기코드\\\filepath{app/controllers/application\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [3]
\begin{code} class ApplicationController < ActionController::Base protect_from_forgery with: :exception include SessionsHelper end \end{code} \end{codelisting} 

\noindent 이 설정으로 사용자 로그인 코드를 작성할 준비가 끝났다. 

\subsection{\texttt{log\_in} 메서드} \label{sec:a_working_log_in_method} 

% (fold)
레일즈가 제공하는 \kode{session} 메서드를 이용하면 사용자를 로그인 시키는 것은 간단히 처리할 수 있다(이 메서드는 섹션\ref{sec:sessions_controller}에서 생성한 세션 컨트롤러와는 연관없다.) \kode{session}은 다음과 같이 해시인 것처럼 다룰 수 있다: 

%= lang:ruby
\begin{code} session[:user_id] = user.id \end{code} 

\noindent 이렇게 하면 사용자의 브라우저에 임시 쿠키에 암호화된 사용자 아이디를 담아 놓을 수 있다. 그리고 이를 다시 읽어올 때는 \kode{session[:user\_id]}으로 접근 할 수 있다. \kode{cookies} 메서드를 이용해 생성한 지속성 쿠키와는 달리(섹션\ref{sec:remember_me}), \kode{session} 메서드로 생성한 쿠키는 브라우저가 닫히면 사라진다. 

로그인을 여러곳에서 공용으로 사용하기 위해서 \kode{log\_in}을 세션 헬퍼에 목록\ref{code:log_in_function}과 같이 정의했다. 

\begin{codelisting} \label{code:log_in_function} \codecaption{\kode{log\_in} 메서드. 코드\\\filepath{app/helpers/sessions\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [5]
\begin{code} module SessionsHelper 

# Logs in the given user. def log_in(user) session[:user_id] = user.id end end \end{code} \end{codelisting} 

\kode{session} 메서드를 이용해 생성한 쿠키는 자동으로 암호화 되기 때문에 목록\ref{code:log_in_function}의 코드는 안전하다. 다시 말해서 공격자가 그 어떤 방법으로도 이 세션 정보를 이용할 수 없다. 이것은 오직 \kode{session}는 메서드를 이용했을 때만 해당되는 것이며,  \kode{cookies} 메서드를 이용하여 유지되는 세션을 생성한 경우에는 \emph{해당되지 않는다.}영구 쿠키는 \emph{세션 하이젝킹} 공격에 취약하다. 따라서 섹션\ref{sec:remember_me} 에서 사용자의 브라우저에 정보를 저장할때는 더욱 주의해야한다. 

목록 \ref{code:log_in_function}에서 작성한 \kode{log\_in} 메서드가 준비되었으니, 사용자를 로그인 시키고 사용자 프로파일 페이지로 리다이렉트 해주는 세션\kode{create} 액션을 만들 준비가 끝났다. 완성된 코드는 목록 \ref{code:log_in_success}이다. 목록 \ref{code:sessions_helper_include}에서 모듈을 인클루드 했으므로 세션 컨트롤러에서 \footnote{ \kode{log\_in} 메서드를 사용할 수 있다.} 

\begin{codelisting} \label{code:log_in_success} \codecaption{사용자 로그인 시키기. 코드\\\filepath{app/controllers/sessions\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [9, 10]
\begin{code} class SessionsController < ApplicationController 

def new end 

def create user = User.find_by(email: params[:session][:email].downcase) if user &&user.authenticate(params[:session][:password]) log_in user redirect_to user else flash.now[:danger] = 'Invalid email/password combination' render 'new' end end 

코드def destroy end end \end{code} \end{codelisting} 

\noindent 리다이렉트는 다음과 같이 간략화 했다 

%= lang:ruby
\begin{code} redirect_to user \end{code} 

\noindent 이 것은 이미 섹션~\ref{sec:the_finished_signup_form}에서 사용한 적이 있다. 레일즈가 자동으로 이 라우트를 사용자 프로파일 페이지 경로로 변환해 준다: 

%= lang:ruby
\begin{code} user_url(user) \end{code} 

목록 \ref{code:log_in_success}에 정의된 \kode{create} 액션이 완성됐으므로 목록 \ref{code:login_form}의 로그인 폼은 이제 작동할 것이다. 하지만 어플리케이션 자체에서는 어떠한 외견 변화는 없다. 현재로써는 브라우저 세션자체로 사용자가 로그인 되었는지 확인할 방법은 없다. 더 시각적인 변화를 만들기 위한 첫번째 단계로 섹션 \ref{sec:current_user}에서는 세션에 저장되어 있는 사용자의 id를 이용하여 데이터베이스에서 사용자를 불러오겠다. 섹션 \ref{sec:changing_the_layout_links}에서 현재 사용자 프로파일 페이지 URL과 더블어 어플리케이션 레이아웃에 있는 링크을 변경할 것이다. 

% subsection a_working_log_in_method (end)
\subsection{Current user} \label{sec:current_user} 

% (fold)
임시 세션에 안전하게 사용자의 아이디를 저장했으니 이번엔 이를 읽어서 각 페이지 사용할 차례다. 이를 위해 세션 아이디에 맞는 사용자를 데이터베이스에서 찾아주는 \kode{current\_user}메서드를 구현해야 한다. \kode{current\_user}는 다음과 같은 용법을 사용할 수 있게 해준다. 

%= lang:rhtml
\begin{code} < \end{code} 

%= current_user.name %>
\noindent 그리고 

%= lang:ruby
\begin{code} redirect_to current_user \end{code} 

사용자를 찾는 한가지 방법은 사용자 프로파일 페이지에서 사용한 것 처럼 \kode{find}메서드를 이용하는 것이다.(목록~\ref{code:user_show_action}): 

%= lang:ruby
\begin{code} User.find(session[:user_id]) \end{code} 

\noindent 하지만 섹션~\ref{sec:finding_user_objects} 에서 언급했듯이 \kode{find} 는 사용자 아이디가 존재하지 않을 경우 예외를 발생시킨다. 이런 동작은 사용자 프로파일 페이지에서는 적당하나 현재의 경우인 \kode{session[:user\_id]}에서는 적당하지 않다 왜냐면 세션아이디는 \kode{nil}인 경우가 존재하기 때문이다. (i.e., 로그인 하지 않은 사용자). 이 경우을 처리하기 위해서는 \kode{create} 메서드에서 이메일 주소로 사용자를 찾을 때 사용한 \kode{find\_by}메서드를 \kode{email} 대신 \kode{id}를 이용하면 된다: 

%= lang:ruby
\begin{code} User.find_by(id: session[:user_id]) \end{code} 

\noindent 이 메서드는 아이디가 유효하지 않을 경우 예외를 발생시키지 않고 \kode{nil}을 반환한다.(아이디에 맞는 사용자가 없는 경우) 

\kode{current\_user} 메서드는 다음과 같다: 

%= lang:ruby
\begin{code} def current_user User.find_by(id: session[:user_id]) end \end{code} 

\noindent 이 방식 일단 제대로 동작은 하지만 \kode{current\_user}가 하나의 페이지에 여러번 있을 경우 계속해서 데이터베이스에 접근하게 된다. 일반적인 루비 관습에 따라서 \kode{User.find\_by}의 결과를 처음에는 인스턴스 변수에 저장하고 이후에는 이 인스턴스 변수를 리턴하도록 할 수 한다.:\footnote{이렇게 하나의 메서드에서 다른 메서드로 변수를 기억하는 방식을 메모이제이션 이라고 한다.\href{http://en.wikipedia.org/wiki/Memoization}{\emph{메모이제이션}}. (메모이제이션은 기술적인 용어 자체로 ``메모라이제션"의 \emph{맞춤법이 틀린것이 아니다}.)} 

%= lang:ruby
\begin{code} if @current_user.nil? @current_user = User.find_by(id: session[:user_id]) else @current_user end \end{code} 

\noindent \emph{or}연산자 \texttt{||}는 섹션 \ref{sec:objects_and_message_passing}에서 이미 사용했었는데, 이를 다음과 같이 다시 작성할 수 있다: 

%= lang:ruby
\begin{code} @current_user = @current_user || User.find_by(id: session[:user_id]) \end{code} 

\noindent User객체가 논리형 판정으로는 참이다. 따라서 \kode{find\_by}는 오직 \kode{@current\_user}가 아직 할당되지 않았을때만 실행된다. 

위 코드는 동작하기는 하지만 루비의 관습상 맞지 않다. \kode{@current\_user}는 다음과 같이 해야 맞는 대입 방법이다: 

%= lang:ruby
\begin{code} @current_user ||= User.find_by(id: session[:user_id]) \end{code} 

\noindent \kode{||=} (``or equals'') 연산자는 혼란을 줄지도 모르지만, 자주 사용된다. (Box~\ref{aside:or_equals}). 

\begin{aside} \label{aside:or_equals} \heading{*\$@!\texttt{||=}은 무엇인가?} 

\texttt{||=} (``or equals'') 대입 연산자는 루비 관용구로 레일즈 개발자로써 익숙해지는것이 중요하다. \emph{or equals} 연산자는 처음에는 이상해 보일지 모르지만, 이해하기 쉽다. 

먼저 일반적인 증가 연산을 살펴보자: 

\begin{verbatim} x = x + 1 \end{verbatim} 

\noindent 많은 언어들이 이 연산의 단축 연산자를 제공한다. 루비(C, C++, Perl, Java등)도 이 연산자를 다음과 같이 제공한다: 

\begin{verbatim} x += 1 \end{verbatim} 

\noindent 유산 구조가 다른 연산자에도 존재한다: 

\begin{verbatim} $ rails console >> x = 1 => 1 >> x += 1 => 2 >> x *= 3 => 6 >> x -= 8 => -2 >> x /= 2 => -1 \end{verbatim} 

\noindent 각각의 경우의 패턴은 \texttt{x = x O y} and \texttt{x O= y}이고 다른 연산자\texttt{O}에 경우도 모두 적용된다. 

다른 일반적인 루비 대입법은 변수가 \texttt{nil}일때만 대입하고 그렇지 않으면 그냥 두는것이다. 섹션 \ref{sec:objects_and_message_passing}에서 사용한 \emph{or}~연산자 \texttt{||}을 상기해보자: 

\begin{verbatim} >> @foo => nil >> @foo = @foo || "bar" => "bar" >> @foo = @foo || "baz" => "bar" \end{verbatim} 

\noindent \texttt{nil}은 논리형 판정에서 거짓으로 판정되기 때문에 첫번째 대입의 \texttt{@foo}에는 \texttt{nil || "bar"}이 대입된다. 결과는 \texttt{"bar"가 된다.}. 똑같이 두번째 대입 \texttt{@foo || "baz"}은 \texttt{"bar" || "baz"}이 되고 대입 결과는 \texttt{"bar"}이다. \texttt{nil} 이나 \texttt{false}을 제외한 모든 값은 \texttt{참}으로 판정되기 때문에 \texttt{||} 연산의 첫번째 값이 참인 경우 판정이 그 상황에서 끝나버린다. (이런 방식의 \texttt{||} 평가식이 왼쪽에서 오른쪽으로 연산이 이루어 질때 왼쪽 값이 참인경우 그 상태에서 연산을 멈추게 되는 데 이를 \emph{short-circuit evaluation}이라고 한다.) 

콘솔의 여러 연산자의 결과를 비교해보면 \texttt{@foo = @foo || "bar"}에서 \texttt{||}을 \texttt{O}로 바꾸어 \texttt{x = x O y} 패턴임을 알수 있다: 

\begin{verbatim} x = x + 1 -> x += 1 x = x * 3 -> x *= 3 x = x - 8 -> x -= 8 x = x / 2 -> x /= 2 @foo = @foo || "bar" -> @foo ||= "bar" \end{verbatim} 

\noindent 위 결과로 \verb+@foo = @foo || "bar"+ 와 \verb+@foo ||= "bar"+ 같음을 알 수 있다. 이를 current user에 적용해서 생각하면 다음과 같이 바꿔 쓸 수 있음을 이해할 수 있을 것이다: 

\begin{verbatim} @current_user ||= User.find_by(id: session[:user_id]) \end{verbatim} 

\noindent Voil\`{a}~! 

\end{aside} 

위에 설명한 내용을 적용 하면 간결한 버전의 \linebreak \kode{cur\-rent\_\-user} 메서드를 다음과 같이 작성할 수 있다.\ref{code:current_user}. 

\begin{codelisting} \label{code:current_user} \codecaption{Finding the current user in the session. 코드\\\filepath{app/helpers/sessions\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [10]
\begin{code} module SessionsHelper 

# Logs in the given user. def log_in(user) session[:user_id] = user.id end 

# 현재 로그인 된 사용자를 반환한다.(존재할 경우에만)def current_user @current_user ||= User.find_by(id: session[:user_id]) end end \end{code} \end{codelisting} 

\noindent 목록 \ref{code:current_user}의 잘 작동하는 \kode{current\_user}가 완성되었으니, 사용자의 로그인 상태에 따라서 어플리케이션을 변화를 만들어줄 차례다. 

% subsection current_user (end)
\subsection{레이아웃 링크 변경하가} \label{sec:changing_the_layout_links} 

% (fold)
첫번째 사용자의 로그인 상태에 따른 변화를 줄 만한 것은 레이아웃 링크이다. 특히 그림 \ref{fig:login_success_mockup} 목업 \footnote{Image from \href{http://www.flickr.com/photos/hermanusbackpackers/3343254977/}{http://www.flickr.com/photos/hermanusbackpackers/3343254977/}.}과 같이 로그아웃 링크와 사용자의 프로파일 페이지 링크를 추가할 것이다. 그림\ref{fig:login_success_mockup}을 보면 로그아웃과 프로파일 링크는 ``Account'' 메뉴에 드랍다운으로 되어 있는데 이는 Bootstrap을 이용해서 목록 \ref{code:layout_login_logout_links}에 작성한데로 구성할 수 있다. 

\begin{figure} \begin{center} \imagebox{images/figures/login_success_mockup.png} \end{center} \caption{성공적으로 로그인한 사용자 프로파일 목업.\label{fig:login_success_mockup}} \end{figure} 

지금이 위에 설명한 동작을 테스트하는 통합 테스트 작성을 고려할 시기이다. 글상자 \ref{aside:when_to_test}을 보면 알듯이 이제 레일즈의 테스트 툴에 익숙해짐에 따라서 테스트를 먼저 작성하고 싶은 유혹을 느끼게 될 것이다. 하지만 이번 경우에는 몇가지 새로운 개념이 포함되어 있어서, 일단 독립된 섹션에서 자세히 다루도록 하겠다.(섹션~\ref{sec:testing_layout_changes}). 

레이아웃에 링크를 바꾸는 방법은, 루비의 if-else문을 이용하여 사용자가 로그인되어 있는 상태일때 하나의 세트의 링크를 노출하고 그렇지 않을때 또 다른 링크 세트를 노출해줘야 한다: 

%= lang:rhtml
\begin{code} < # Links for logged-in users < # Links for non-logged-in-users < \end{code} 

% if logged_in? %>% else %>% end %>
\noindent 이런 동작을 위해서 \kode{logged\_in?}\ 논리형 메서드가 필요하다. 이를 이제 정의 해보자. 

current user가 세션에 존재하면 사용자가 로그인 한 상태이,다 \linebreak 즉\kode{current\_\-user} 가 \kode{nil} 아닐 때이다. 여기서 ``not'' 연산자가 필요하다. (Section~\ref{sec:objects_and_message_passing}), 작성할때는 느낌표 \kode{!} 사용하고 ``bang''이라고 읽는다. \kode{logged\_in?}\ 메서드는 결론적으로 목록 \ref{code:logged_in_p}과 같이 작성하면 된다. 

\begin{codelisting} \label{code:logged_in_p} \codecaption{The \kode{logged\_in?}\ helper method. 코드\\\filepath{app/helpers/sessions\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [15]
\begin{code} module SessionsHelper 

# Logs in the given user. def log_in(user) session[:user_id] = user.id end 

# 현재 로그인 된 사용자를 반환한다.(존재할 경우에만)def current_user @current_user ||= User.find_by(id: session[:user_id]) end 

# Returns true if the user is logged in, false otherwise. def logged_in?!current_user.nil?코드end end \end{code} \end{codelisting} 

목록 \ref{code:logged_in_p}을 추가함으로써 로그인한 사용자의 레이아웃 링크를 변경할 준비는 끝났다. 4개의 링크가 있는데 이중에 두개는 스텁해놓았다. (\ref{cha:updating_showing_and_deleting_users}장에서 완성할 예정임): 

%= lang:rhtml
\begin{code} < < \end{code} 

%= link_to "Users",    '#' %>%= link_to "Settings", '#' %>
\noindent 한편으로 로그아웃 링크는 목록 \ref{code:sessions_resource}의 로그아웃 경로를 사용한다: 

%= lang:rhtml
\begin{code} < \end{code} 

%= link_to "Log out", logout_path, method: :delete %>
\noindent 로그아웃 링크를 살펴보면 해시 인자로 이 요청은 HTTP \texttt{DELETE} 로 서브밋 되어야 함을 설정했다.\footnote{웹브라우저는 실재로는 \texttt{DELETE} 요청을 보낼 수 없기때문에; 레일즈에서는 자바스크립트를 이용하여 이를 대신해준다.} 프로파일 링크는 다음과 같다: 

%= lang:rhtml
\begin{code} < \end{code} 

%= link_to "Profile", current_user %>
\noindent Here we could write 

%= lang:rhtml
\begin{code} < \end{code} 

%= link_to "Profile", user_path(current_user) %>
\noindent 지금까지 여러번 해왔듯이 레일즈는 \kode{current\_user}를 \kode{user\_path(current\_user)}로 자동으로 변환해준다. 마지막으로 사용자가 로그인 하지 \emph{않았을때}, 목록 \ref{code:sessions_resource}에 정의된데로 로그인 폼으로 이동하는 링크를 넣어준다. 

%= lang:rhtml
\begin{code} < \end{code} 

%= link_to "Log in", login_path %>
\noindent 지금까지 작성한 코드를 모두 포함한 헤더 파셜은 목록 \ref{code:layout_login_logout_links}과 같다 

\begin{codelisting} \label{code:layout_login_logout_links} \codecaption{로그인 사용자의 레이아웃 링크 바꾸기. 코드\\\filepath{app/views/layouts/\_header.html.erb}} 

%= lang:rhtml, options: "hl_lines": [8, 9, 15, 16, 19, 23, 24, 25]
\begin{code} <header class="navbar navbar-fixed-top navbar-inverse"> <div class="container"> < <nav> <ul class="nav navbar-nav navbar-right"> <li>< <li>< < <li>< <li class="dropdown"> <a href="#" class="dropdown-toggle" data-toggle="dropdown"> Account <b class="caret"></b> </a> <ul class="dropdown-menu"> <li>< <li>< <li class="divider"></li> <li> < </li> </ul> </li> < <li>< < </ul> </nav> </div> </header> \end{code} \end{codelisting} 

%= link_to "sample app", root_path, id: "logo" %>%= link_to "Home", root_path %></li>%= link_to "Help", help_path %></li>% if logged_in? %>%= link_to "Users", '#' %></li>%= link_to "Profile", current_user %></li>%= link_to "Settings", '#' %></li>%= link_to "Log out", logout_path, method: "delete" %>% else %>%= link_to "Log in", login_path %></li>% end %>
레이아웃에 추가된 목록 \ref{code:layout_login_logout_links}의 새로운 링크들은 Bootstrap이 드랍다운 메뉴로 바꾸어 준다.\footnote{\href{http://getbootstrap.com/components/}더 자세한 내용은 {Bootstrap components page} 참조} 특별한 Bootstrap CSS를 사용하기 위해서 \kode{dropdown}, \kode{dropdown-menu}같은 클래스를 넣은부분을 주목하자. 드랍다운 메뉴가 제대로 동작하게 하기 위해서는 Boostrap의 커스텀 자바스크립트 라이브러리를 레일즈 어셋 파이프라인 설정을 하는 \kode{ap\-pli\-ca\-tion.js} 파일에 목록~\ref{code:bootstrap_js}과 같이 추가해 줘야한다. 

\begin{codelisting} \label{code:bootstrap_js} \codecaption{\kode{application.js}에 Bootstrap 자바스크립트 라이브러리 추가하기. 코드\\\filepath{app/assets/javascripts/application.js}} 

%= lang:js, options: "hl_lines": [3]
\begin{code} //= require jquery //= require jquery_ujs //= require bootstrap //= require turbolinks //= require_tree . \end{code} \end{codelisting} 

% \noindent This uses the Sprockets library to include the Bootstrap JavaScript, which in turn is available thanks to the \texttt{bootstrap-sass} gem from Section~\ref{sec:custom_css}.
이제 이미 이전 세개 섹션\footnote{만약 클라우드 IDE를 사용중이라면, 로그인 동작을 테스트할때 다른 브라우저를 사용하기를 권장한다. 그래야만 IDE가 동작중인 브라우저를 닫지 않아도 된다.}의 테스트로 검증된 로그인 경로에 접근하여 유효한 사용자 정보로 로그인 해보자. 목록 \ref{code:layout_login_logout_links}와 목록 \ref{code:bootstrap_js}이 만들어낸 드랍다운 메뉴의 링크들을 그림 \ref{fig:profile_with_logout_link}과 같이 확인할 수 있을 것이다. 브라우저를 완전히 닫아 어플리케이션이 당신의 로그인 상태를 완전히 잃어버리고, 브라우저를 다시 실행시켜 재 접근했을때 이 섹션에서 작업한 변화하는 링크가 제대로 보이는지 확인해보자. 

\begin{figure} \begin{center} \image{images/figures/profile_with_logout_link_3rd_edition.png} \end{center} \caption{로그인한 사용자의 새로운 드랍다운 링크.\label{fig:profile_with_logout_link}} \end{figure} 

% subsection changing_the_layout_links (end)
\subsection{레이아웃 변경 테스트} \label{sec:testing_layout_changes} 

% (fold)
수동으로 어플리케이션의 로그인 성공 여부를 확인했으니, 다음 단계로 넘어가기 전에 이 동작을 테스트 해주는 토합 테스트를 작성해보자.  목록 \ref{code:flash_persistence_test} 테스트에 다음 액션 시퀀스를 검증하도록 하는 테스트를 작성하겠다: 

\begin{enumerate} \item 로그인 화면에 접근한다. \item 세션 경로에 유효한 정보를 post로 요청을 보낸다. \item 로그인 링크가 사라지는지 검증한다. \item 로그아웃 링크가 생성되는지 검증한다. \item 프로파일 링크가 생성되는지 검증한다. \end{enumerate} 

이런 변화를 검증하는 테스트는 기존에 이미 데이터베이스에 등록된 사용자가 필요하다. 디폴트 레일즈의 방식을 따르는 방법으로는 \emph{픽스쳐}을 이용하는 것이다. 픽스쳐는 자동으로 테스트 데이터베이스에 로드되는 데이터 이다. 이미 섹션~\ref{sec:uniqueness_validation} 에서 이메일 유일성 체크 를 통과하기 위해서 디폴트 픽스쳐를 삭제해야 함을 이미 보았다.(목록~\ref{code:empty_fixtures}). 이제 커스텀 픽스쳐를 우리가 원하는 내용을 채워 넣을 준비가 끝났다. 

지금은 일단 유한 이름과 이메일을 가진 한명의 사용자만 있으면 된다. 사용자를 로그인 시켜야 하기 때문에 세션 컨트롤러 \kode{create} 액션에 서브밋할 유효한 비밀번호도 필요하다. 그림 \ref{fig:user_model_password_digest}의 데이터 모델을 살펴보면, 사용자 픽스쳐을 만들기 위해서 \kode{password\_digest} 속성을 생성하는 \kode{digest} 메서드를 만들어야 함을 알 수 있다. 

섹션 \ref{sec:a_hashed_password}에서 이미 언급했듯이, password digest는 bcrypt을 이용하여 생성한다. (\kode{has\_secure\_password}을 통해서) 따라서 픽스쳐 비밀번호를 생성할때도 같은 메서드를 사용해야한다. \href{https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb}{안전한 비밀번호 소스코드}을 살펴보면, 우리가 필요한 매서드는 다음과 같다. 

%= lang:ruby
\begin{code} BCrypt::Password.create(string, cost: cost) \end{code} 

\noindent \kode{string}은 해시화 할 문자열이고 \kode{cost} 는 해시를 계산하는 사용되는 연산 비용을 결정하는 \emph{비용 매개변수 }이다. 높은 비용을 사용하면 해시로부터 비밀번호을 추출하는데 더 어렵게 만드는 것을 의미한다. 프로덕션 환경에서는 보안을 위해서 중요한 값이지만, 테스트에서는 \kode{digest} 메서드는 가능하면 빠르게 하는것이 좋다. 안전한 비밀번호 소스코드는 다음과 같은 라인이 있다. 

%= lang:ruby
\begin{code} cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost \end{code} 

\noindent 이 코드는 약간 모호하지만 자세한 내용을 모두 이해할 필요는 없다. 간단히 정리하면 테스트에서는 최소 비용을 매개변수로 사용하고, 프로덕션에서는 보통(높음) 비용 매개변수를 사용하면 된다. (위에서 사용한 이상한 \kode{?}-\kode{:} 표현은 섹션 \ref{sec:remember_me_checkbox}에서 다루겠다.) 

\kode{digest} 메서드는 여러곳에 넣을 수 있지만, 섹션~\ref{sec:remember_token}에서 user 모델에서 \kode{digest} 을 다시 사용할 기회가 있다. \kode{user.rb}에 넣어보자. digest를 계산할때 user 객체에 접근 하지 않을 것이기 때문에 (섹션 \ref{sec:constructors}에서 간단히 살펴 봤듯이) 간단히 \emph{클래스 메서드}로 만들겠다. 결과는 목록 \ref{code:digest_method}과 같다. 

\begin{codelisting} \label{code:digest_method} \codecaption{픽스쳐에서 사용할 digest 메서드 추가 하기. 코드\\\filepath{app/models/user.rb}} 

%= lang:ruby, options: "hl_lines": [13, 14, 15]
\begin{code} class User < ActiveRecord::Base before_save { self.email = email.downcase } validates :name, presence: true, length: { maximum: 50 } VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false } has_secure_password validates :password, length: { minimum: 6 } 

# Returns the hash digest of the given string. def User.digest(string) cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost BCrypt::Password.create(string, cost: cost) end end \end{code} \end{codelisting} 

목록 \ref{code:digest_method}의 \kode{digest} 메서드로 목록 \ref{code:real_user_fixture} 보여지는 것처럼 유효한 사용자 픽스쳐를 만들 준비가 끝났다. 

\begin{codelisting} \label{code:real_user_fixture} \codecaption{사용자 로그인을 위한 픽스쳐. 코드\\\filepath{test/fixtures/users.yml}} 

%= lang:yaml
\begin{code} michael: name: Michael Example email: michael@example.com password_digest: < \end{code} \end{codelisting} 

%= User.digest('password') %>
\noindent 픽스쳐가 ERB을 지원해서 테스트 사용자의 유효한 비밀번호 digest을 다음과 같이 생성할 수 있게 해준다. 

%= lang:ruby
\begin{code} < \end{code} 

%= User.digest('password') %>
\noindent to create the valid password digest for the test user. 

\kode{has\_secure\_password}을 위해서 \kode{password\_digest} 속성을 정의 했지만, 때때로 보통(가상) 비밀번호를 만들때도 편리하다. 불행하게도 \kode{비밀번호} 속성을 목록 \ref{code:real_user_fixture} 에 바로 픽스쳐에 넣는 것은 불가능하다. 왜냐면 이를 시도하면 레일즈가 데이터베이스에 비밀번호라는 컬럼을 존재하지 않는다고 에러를 발생시키기 때문이다. 모든 픽스쳐 사용자는 같은 비밀번호 (\kode{'password'})을 갖도록 하겠다. 

유효한 사용자 픽스쳐를 완성했으니, 테스트 내에서 다음과 같은 방법으로 사용자를 불러올 수 있다. 

%= lang:ruby
\begin{code} user = users(:michael) \end{code} 

\noindent 여기서 \kode{users}는 픽스쳐 파일명 \kode{users.yml} 대응된다. \kode{:michael} 심벌을 키로 목록 \ref{code:real_user_fixture}에 정의된 사용자를 가리킨다.  

이 픽스쳐 사용자로 레이아웃 링크 테스트를 목록 \ref{code:user_login_test_valid_information}과 같이 이 섹션에서 한 작업들을 순서대로 테스트 할 수 있다. 

\begin{codelisting} \label{code:user_login_test_valid_information} \codecaption{유효한 정보을 가진 사용자 로그인 테스트코드\passing \\\filepath{test/integration/users\_login\_test.rb}} 

%= lang:ruby, options: "hl_lines": [5, 6, 7]
\begin{code} 코드require 'test_helper' 

class UsersLoginTest < ActionDispatch::IntegrationTest 

def setup @user = users(:michael) end . 코드. 코드. test "login with valid information" do get login_path post login_path, session: { email: @user.email, password: 'password' } assert_redirected_to @user follow_redirect!assert_template 'users/show' assert_select "a[href=?]", login_path, count: 0 assert_select "a[href=?]", logout_path assert_select "a[href=?]", user_path(@user) end end \end{code} \end{codelisting} 

\noindent Here we've used 

%= lang:ruby
\begin{code} assert_redirected_to @user \end{code} 

\noindent 위 코드는 제대로 리다이렉트가 되는지 확인한다. 

%= lang:ruby
\begin{code} follow_redirect! \end{code} 

\noindent 실제로 목적지에 이동하는 것은 위 코드로 할 수 있다. 목록 \ref{code:user_login_test_valid_information}과 같이 로그인 링크가 사라지는지 여부는 \emph{0}개의 로그인 경로 링크가 페이지에 존재하는지 확인하여 검증한다: 

%= lang:ruby
\begin{code} assert_select "a[href=?]", login_path, count: 0 \end{code} 

\noindent 추가적인 \kode{count: 0} 옵션을 넣어서 \kode{assert\_select} 가 0개의 링크가 존재하는 검증하게 한다. (목록 \ref{code:layout_links_test}의 \kode{count: 2}는 정확히 두개의 매칭되는 링크가 있는지 검증한다.) 

어플리케이션은 이미 동작하고 있었으므로 테스트 결과는 \linebreak \passing이다: 

\begin{codelisting} \codecaption코드{\passing} 

%= lang:text
\begin{code} $ bundle exec rake test TEST=test/integration/users_login_test.rb \> TESTOPTS="--name test_login_with_valid_information" \end{code} \end{codelisting} 

\noindent 위와 명령어는 특정 테스트 파일의 특정 테스트 명을 넣어서 원하는 테스트만 실행하는 법이다. 

%= lang:console
\begin{code} TESTOPTS="--name test_login_with_valid_information" \end{code} 

\noindent containing the name of the test. (테스트 명이 단순히 단어 하나면 ``test''와 같이 적고, 여러 단어로 구성되어 있으면 밑줄로 연결하면 된다.) 

% subsection layout_link_tests (end)
\subsection{가입과 동시에 로그인하기} \label{sec:login_upon_signup} 

% (fold)
일단 어플리케이션의 인증 시스템은 작동하지만, 새로 등록한 사용자는 디폴트로 바로 로그인이 되지 않아 혼란스러워 할 수 있다. 가입한 직후, 사용자에게 바로 다시 로그인하도록 하는것은 이상할 수 있기때문에 새로운 가입자에게 자동으로 로그인되도록 하는것은 가입 절차의 과정으로 넣도록 하자. 이 동작을 구현하기 위해 해야 할일은 목록 \ref{code:login_upon_signup}과 같이 user컨트롤러의 \kode{create} 액션에서 \kode{log\_in}을 한번 호출 해주는 것 뿐이다. \footnote{As with the Sessions controller, the \kode{log\_in} 메서드는 목록 \ref{code:sessions_helper_include}에서 이미 인클루드 했기 때문에 user 컨트롤러에서 바로 호출 가능하다.} 

\begin{codelisting} \label{code:login_upon_signup} \codecaption{가입한 사용자 로그인 시키기. 코드\\\filepath{app/controllers/users\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [14]
\begin{code} class UsersController < ApplicationController 

def show @user = User.find(params[:id]) end 

def new @user = User.new end 

def create @user = User.new(user_params) if @user.save log_in @user flash[:success] = "Welcome to the Sample App!" redirect_to @user else render 'new' end end 

private 

def user_params params.require(:user).permit(:name, :email, :password, :password_confirmation) end end \end{code} \end{codelisting} 

목록 \ref{code:login_upon_signup}의 동작을 테스트 하기 위해서, 사용자가 로그인 했는지 목록 \ref{code:a_test_for_valid_submission}에 코드라인 하나를 추가 했다. 목록 \ref{code:logged_in_p}에 정의 된\kode{logged\_in?}\ 과 더불어 (테스트) 세션에 사용자 아이디가 있으면 \kode{참}을 반환하고 그렇지 않으면 거짓을 반환하는 \kode{is\_logged\_in?}\ (목록 \ref{code:test_helper_sessions}) 헬퍼 메서드를 정의해 놓는것은 도움이 된다. (왜냐면 헬퍼 메서드를 테스트 내에서는 사용하지 못하기 때문이다. 즉 목록 \ref{code:logged_in_p}의 \kode{current\_user}을 사용하지 못한다. 대신 \kode{session} 메서드는 사용 가능하므로 이를 사용한다.) \kode\kode{logged\_in?}\ 대신 {is\_logged\_in?}\ 을 사용하는데 있어서, 테스트 헬퍼 메서드와 세션 헬퍼 매소드의 이름을 서로 다르게 하여 실수로 두 메서드를 잘 못 사용하는 것을 방지했다.\footnote{한번은 실수로 \kode{log\_in을 통채로 지워버렸는데도, 나의 테스트 스위트 결과는 \passing\ 이었다.} 세션헬퍼 메서드. 어플리케이션은 완전히 망가졌는데도 불구하고, 테스트는 같은 이름의 테스트 헬퍼를 사용하고 있고 당연히 테스트를 성공했었다. \kode{is\_logged\_in?}의 이런 이슈를 피하기 위해서 목록 \ref{code:test_helper_log_in}의 \kode{log\_in\_as}을 정의 했다.} 

\begin{codelisting} \label{code:test_helper_sessions} \codecaption{테스트 내 로그인 상태 논리형 메서드 코드\\\filepath{test/test\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [9, 10, 11]
\begin{code} ENV['RAILS_ENV'] ||= 'test' . 코드. 코드. class ActiveSupport::TestCase fixtures :all 

# Returns true if a test user is logged in. def is_logged_in?!session[:user_id].nil?코드end end \end{code} \end{codelisting} 

\noindent 목록 \ref{code:test_helper_sessions}코드로 가입후 바로 로그인 되는 지를 목록\ref{code:login_after_signup_test} 과 같이 확인할 수 있다. 

\begin{codelisting} \label{code:login_after_signup_test} \codecaption{가입후 로그인 테스트. 코드\passing \\\filepath{test/integration/users\_signup\_test.rb}} 

%= lang:ruby, options: "hl_lines": [16]
\begin{code} 코드require 'test_helper' 

class UsersSignupTest < ActionDispatch::IntegrationTest . 코드. 코드. test "valid signup information" do get signup_path assert_difference 'User.count', 1 do post_via_redirect users_path, user: { name: "Example User", email: "user@example.com", password: "password", password_confirmation: "password" } end assert_template 'users/show' assert is_logged_in?코드end end \end{code} \end{codelisting} 

이 시점에서 테스트 스위트의 결과는 \passing일 것이다.: 

\begin{codelisting} \codecaption코드{\passing} 

%= lang:text
\begin{code} 코드$ bundle exec rake test \end{code} \end{codelisting} 

% subsection login_upon_signup (end)
% section login_success (end)
\section{로그아웃} \label{sec:logging_out} 

% (fold)
섹션 \ref{sec:sessions_and_failed_login}에서 이미 언급했듯이 인증 모델의 사용자의 로그인 상태를 명시적으로 로그아웃할때까지 유지한다. 이 섹션에서는 이에 필요한 로그아웃 기능을 구현하겠다. 이미 ``로그아웃'' 링크는 정의 했으니(목록~\ref{code:layout_login_logout_links}), 해야 할 일은 사용자의 세션을 삭제하는 컨트롤러 액션을 작성하는 것 뿐이다. 

현재 세션 컨트롤러는 로그인 페이지를 위한 \kode{new},  로그인을 하는 \kode{create} 액션만 있다. 세션을 삭제하는 즉 로그아웃 시키는  \kode{destroy} 액션을 작성하자. 목록 \ref{code:log_in_success} 과 목록 ~\ref{code:login_upon_signup} 두군데에서 사용하는 로그인 기능과는 다르게, 로그아웃은 한 곳에서만 사용할 것이기 때문에 헬퍼를 사용하지 않고 \kode{destroy}에 바로 코드를 넣어도 된다. 이 디자인(약간의 리팩토링 후)은 인증 기능을 테스트 하기 쉽게 해주는것을 섹션 \ref{sec:remember_tests}에서 확인할 것이다. 

로그아웃은 세션에서 사용자 아이디를 제거하는 등의 목록 \ref{code:log_in_function}의 \kode{log\_in} 메서드가 했던 작업을 되돌리는 작업들을 하게 된다.\footnote{ 어떤 브라우저는 재 방문했을대 자동으로 세션을 복구해주는 ``\href{http://stackoverflow.com/questions/20449641/rails-4-session-value-never-expires-or-dies-when-browser-closes을 }{마지막 방문했던 곳 기억하기}''같은 기능을 제공하는데 이런 기능도 작동하지 않도록 확실히 로그아웃 시켜야한다} \kode{delete} 메서드는 다음과 같다: 

%= lang:ruby
\begin{code} session.delete(:user_id) \end{code} 

\noindent current user를 \kode{nil}로 설정하면 바로 root URL로 리다이렉트 되기 때문에 현재로써는 문제 된지 않는다. \footnote{\kode{@current\_user을 } \kode{nil} 로 설정하는 것이 문제가 되는 경우는 오직 \kode{@current\_user} 가 설정되기 전에 \kode{destroy} 액션 요청이 들어왔을 때 바로 리다이렉트를 하지 않았을 경우이다. 이런 경우는 잘 생기기 어렵고, 현재 구성하고 있는 어플리케이션의 반드시 필요하지는 않지만, 보안관련 이슈이므로 완성도를 위해서 추가 해두었다.} \kode{log\_in}와 이와 관련되어 있는 메서드, \kode{log\_out} 메서드는 세션 헬퍼 모듈에 넣었다(목록 \ref{code:log_out_method}). 

% \footnote{Manipulating the \kode{@current\_user} variable directly as in Listing~\ref{code:destroy_session} is a little unclean, and in general it would be preferable to define a \emph{setter method} in the Sessions helper called \kode{current\_user=} to allow code like \kode{self.current\_user = nil}. In this case, though, the line doesn't even matter due to the immediate redirect, and setter methods are potentially confusing, so including it here seems like overkill. (Plus, what is \kode{self} doing in that assignment? The answer is that it refers to the \emph{controller itself}, and is necessary to prevent the creation of a \emph{local} variable called \kode{current\_user}. Like I said: \emph{overkill}.)}
\begin{codelisting} \label{code:log_out_method} \codecaption{The \kode{log\_out} method. 코드\\\filepath{app/helpers/sessions\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [12, 13]
\begin{code} module SessionsHelper 

# Logs in the given user. def log_in(user) session[:user_id] = user.id end . 코드. 코드. # Logs out the current user. def log_out session.delete(:user_id) @current_user = nil end end \end{code} \end{codelisting} 

\kode{log\_out} 메서드는 목록 \ref{code:destroy_session}에서 보듯이 세션 컨트롤러의 \kode{de\-stroy} 에 넣었다. 

\begin{codelisting} \label{code:destroy_session} \codecaption{Destroying a session (user logout). 코드\\\filepath{app/controllers/sessions\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [18, 19]
\begin{code} class SessionsController < ApplicationController 

def new end 

def create user = User.find_by(email: params[:session][:email].downcase) if user &&user.authenticate(params[:session][:password]) log_in user redirect_to user else flash.now[:danger] = 'Invalid email/password combination' render 'new' end end 

def destroy log_out redirect_to root_url end end \end{code} \end{codelisting} 

로그아웃 기능을 테스트하기 위해서, 목록 \ref{code:user_login_test_valid_information}의 사용자 로그인에 몇가지 단계를 추가했다.. 로그인을 한 후, \kode{delete} 액션에 \texttt{DELETE} 요청을 로그아웃 경로(표~\ref{table:RESTful_sessions})에 보내고, 로그아웃되고 root URL로 리다이렉트 되는지 검증한다. 또 로그인 링크가 다시 생기는지, 로그아웃과 프로필 링크가 없어지는지도 확인할 수 있다. 목록 \ref{code:user_logout_test}의 새로운 단계. 

\begin{codelisting} \label{code:user_logout_test} \codecaption{로그아웃 테스트. 코드\passing \\\filepath{test/integration/users\_login\_test.rb}} 

%= lang:ruby, options: "hl_lines": [7, 10, 17, 18, 19, 20, 21, 22, 23]
\begin{code} 코드require 'test_helper' 

class UsersLoginTest < ActionDispatch::IntegrationTest . 코드. 코드. test "login with valid information followed by logout" do get login_path post login_path, session: { email: @user.email, password: 'password' } assert is_logged_in?assert_redirected_to @user follow_redirect!assert_template 'users/show' assert_select "a[href=?]", login_path, count: 0 assert_select "a[href=?]", logout_path assert_select "a[href=?]", user_path(@user) delete logout_path assert_not is_logged_in?assert_redirected_to root_url follow_redirect!assert_select "a[href=?]", login_path assert_select "a[href=?]", logout_path, count: 0 assert_select "a[href=?]", user_path(@user), count: 0 end end \end{code} \end{codelisting} 

\noindent (\kode{is\_logged\_in?}\ 을 테스트에서 사용 가능 하기 때문에, \kode{assert is\_logged\_in?}\ 도 유효한 정보를 세션 경로에 post로 요청한 후 덤으로 바로 사용하여 테스트 할 수 있다.) 

\kode{destroy} 액션을 정의하고 테스트완료 했으므로, 초기 가입, 로그인, 로그아웃 삼총사가 완성되었다. 테스트 스위트는 결과는 \passing이다: 

\begin{codelisting} \codecaption코드{\passing} 

%= lang:text
\begin{code} 코드$ bundle exec rake test \end{code} \end{codelisting} 

\section{로그인 유지하기} \label{sec:remember_me} 

% (fold)
섹션 \ref{sec:logging_in}에서 로그인 시스템을 완성했다. 하지만, 많은 웹사이트들은 이 기본 기능외에 브라우저가 닫힌 후에도 사용자의 세션을 유지시켜 주는 기능을 제공한다. 이 섹션에서는 디폴트로 사용자의 로그인 세션을 기억하고 사용자가 명시적으로 로그아웃 했을때만 만료되도록 하겠다. 섹션 \ref{sec:remember_me_checkbox}에서 일반적인 대안 모델인  ``remember me'' 체크 박스로 사용자가 로그인 유지할 것인지 의도를 표시할 수 있도록 할 것이다. 이 모델은 모두 전문가 급으로 맨 처음으로 \href{http://github.com/}{GitHub}, \href{http://bitbucket.org/}{Bitbucket}에서 적용했고, 두 번째로 \href{http://www.facebook.com/}{Facebook}, \href{http://twitter.com/}{Twitter}에서 사용했다. 

\subsection{토큰과 다이제스트 기억하기} \label{sec:remember_token} 

% (fold)
섹션 \ref{sec:logging_in}에서 사용자의 아이디를 저장하기 위해서 레일즈의 \kode{session} 메서드를 사용했다. 하지만 이렇게 저장한 정보는 브라우저가 닫히면 사라진다. 이 섹션에서 유지되는 세션을 구현하기 위해 할 첫번째 작업은 \emph{기억하기 토큰}을 생성하여 이를 안전하게 \emph{remember digest}로 만든 후 이를 \kode{cookies} 메서드를 이용하여 영구적인 쿠키에 저장하는 것이다. 

섹션 \ref{sec:a_working_log_in_method}에서 이미 봤듯이, \kode{session}으로 저장된 정보는 자동적으로 안전하다. 그러나 \kode{cookies}에 있는 정보는 그렇지 않다. 특히 지속적 남는 쿠키는 \href{http://en.wikipedia.org/wiki/Session_hijacking}{session hijacking}에 취약하다. 공격자는 이 기억하기 토큰을 이용하여 특정 사용자로 가장하여 로그인 할 수 있다. 쿠키를 훔치는 방법은 크게 4가지가 있다: (1)\href{https://en.wikipedia.org/wiki/Packet_analyzer}{packet sniffer}을 이용하여 안전하지 않은 네트워크의 패킷을 가로채는 것, \footnote{세션 하이젝킹은 \href{http://codebutler.com/firesheep}공용 와이파이에 접속되어 있는 상태에서 {Firesheep}을 이용하여 기억하기 토큰을 추출할 수 있음이 널리 알려져 있다.} (2) 데이터베이스에 저장되어 있는 기억하기 토큰 가로채기,  (3)\href{http://en.wikipedia.org/wiki/Cross-site_scripting}{사이트 간 스크립팅(XSS)}, 을 이용하기 (4) 로그인 한 사용자의 단말에 직접 접근하기. 첫번째 방법은 섹션 \ref{sec:professional_grade_deployment}에서 packet sniffer로 부터 네트워크 팩킷을 보호해주는 \href{https://en.wikipedia.org/wiki/Transport_Layer_Security}{Secure Sockets Layer} (SSL) 를 사용하여 차단할 것이다. 두번째 문제는 기억하기 토큰 그 자체를 저장하지 않고  섹션 \ref{sec:adding_a_secure_password}에서 한 것과 같은 방식으로 비밀번호를 바로 저장하지 않고 비밀번호 다이제스트를 만들어 저장한 것과 같은 방식으로 다이제스트로 바꿔서 저장하여 막을 수 있다. 레일즈는 자동으로 뷰 템플릿에 들어가는 내용을 이스케이프 해주기때문에 자동으로 세번째 문제를 막아준다. 마지막으로 공격자가 사용자의 단말에 접근을 막을 수 있는 방법은 없지만, 사용자가 로그아웃할 때마다 토큰을 변경하고 잠정적으로 민감한 정보를 브라우저에 저장할때, \emph{암호화 }하여 저장하여 위험을 최소화 할 것이다. 

이런 보안 이슈를 감안하고 유지되는 세션을 만들기 위한 계회은 다음과 같다. 

\begin{enumerate} \item 기억하기 토큰에 따라 랜덤 문자열을 생성한다. \item 토큰을 브라우저 쿠키에 만료일을 미래에 날짜로 해서 저장한다. \item 토큰의 해시 다이제스트를 데이터 베이스에 저장한다. \item 암호화된 사용자 아이디를 브라우저 쿠키에 저장한다. \item 저장되어 있는 사용자 아이디가 있으면 이 아이디로 데이터베이스에서 사용자를 찾은 다음 기억하기 토큰 쿠키와 데이터베이스에 해시 다이제스트와 일치 여부를 대조한다. \end{enumerate} 

\noindent 마지막 단계가 사용자 정보를 이메일로 데이터베이스에서 찾아 비밀번호 다이제스트와 서밋된 비밀번호를 대조하여 사용자를 로그인 시키는 것과 비슷한 것을 주목하기 바란다.(\kode{authenticate} 메서드를 사용하는 것)(목록~\ref{code:find_authenticate_user}). 결과적으로 이런 구현방식은 \kode{has\_secure\_password}과 비슷하다. 

그림\ref{fig:user_model_remember_digest}과 같이 우선 \kode{remember\_digest} 속성을 사용자 모델에 추가하는 것부터 시작하자. 

\begin{figure} \begin{center} \includegraphics{images/figures/user_model_remember_digest.pdf} \end{center} \caption{\kode{remember\_digest} 속성이 추가된 사용자 모델.\label{fig:user_model_remember_digest}} \end{figure} 

\noindent 그림 \ref{fig:user_model_remember_digest}의 데이터 모델을 어플리케이션에 추가하기 위해서 마이그레이션을 생성한다: 

%= lang:console
\begin{code} $ rails generate migration add_remember_digest_to_users remember_digest:string \end{code} 

\noindent (섹션 \ref{sec:a_hashed_password}의 비밀번호 다이제스트와 비교해서 살펴 보자.) 이전 마이그레이션을 생성할때 마이그레이션의 이름은 끝은 \kode{\_to\_users}으로 해서 레일즈에게 데이터베이스의 \kode{users} 테이블을 변경하는 것임을 알려줄 수 있다. (\kode{remember\_digest})의 속성을 (\kode{string})으로 했기 때문에, 레일즈는 목록 \ref{code:add_remember_digest_to_users_generated}과 같은 디폴트 마이그레이션을 생성해준다. 

\begin{codelisting} \label{code:add_remember_digest_to_users_generated} \codecaption{생성된 remember digest 마이그레이션. 코드\\\filepath{db/migrate/[timestamp]\_add\_remember\_digest\_to\_users.rb}} 

%= lang:ruby
\begin{code} class AddRememberDigestToUsers < ActiveRecord::Migration def change add_column :users, :remember_digest, :string end end \end{code} \end{codelisting} 

사용자을 \kode{remember\_digest} 을 조건의 찾을 경우는 없기 때문에 인덱스를 걸 필요는 없고 위에 생성된 마이그레이션을 그대로 사용하면 된다. 

%= lang:text
\begin{code} 코드$ bundle exec rake db:migrate \end{code} 

이제 무엇을 기억하기 토큰으로 사용할지만 결정하면 된다. 아무 어느정도 길이가 되는 랜덤 문자열이면 어느것이나 상관없다. 루비 기본 라이브러리에 \kode{SecureRandom} 모듈의 \kode{urlsafe\_base64} 메서드면 우리 요구사항에 구색이 맞는다:\footnote{이 선택은 \href{http://railscasts.com/episodes/274-remember-me-reset-password}{사용자 기억하기 레일즈즈캐스트}을 따랏다.} 이 메서드는 A--Z, a--z, 0--9, ``-'', ``\_''(총 64개의 가능한 문자을 이용해서 ``\href{http://en.wikipedia.org/wiki/Base64}{base64}''라고 한다.)으로 구성된 22자 랜덤 문자열을 반환한다. 전형적인 base64문자열은 다음과 같다: 

%= lang:console
\begin{code} $ rails console >> SecureRandom.urlsafe_base64 => "q5lt38hQDc_959PVoo6b7A" \end{code} 

두 사용자가 같은 비밀번호를 가지고 있어도 괜찮다.\footnote{bcrypt's \href{https://en.wikipedia.org/wiki/Salt_ 

%28cryptography%29}{salted hashes} there's no way for us to tell if two users' passwords match.} there's no need for remember tokens to be unique, but it's more secure if they are.\footnote{With unique remember tokens, an attacker always needs \emph{both} the user id and the remember token cookies to hijack the session.} In the case of the base64 string above, each of the 22 characters has 64 possibilities, so the probability of two remember tokens colliding is a negligibly small $1/64^{22} = 2^{-132} \approx 10^{-40}$. As a bonus, by using base64 strings specifically designed to be safe in URLs (as indicated by the name \kode{urlsafe\_base64}), we'll be able to use the same token generator to make account activation and password reset links in Chapter~\ref{cha:account_activation_and_password_reset}.
사용자를 기억하는 것은 기억하기 토큰을 생성하고 이 토큰의 다이제스트를 데이터베이스에 저장하는 과정을 필요로 한다. 테스트 픽스쳐(Listing~\ref{code:digest_method})에서 \kode{digest} 메서드를 이미 정의 했으므로, \kode{new\_token} 메서드를 새로운 토큰을 생성하는데 사용할 수 있다.. \kode{digest}로 새 토큰 메서드는 사용자 객체가 필요없다. 따라서 이를 클래스 메서드로 바꾸었다. 이렇게 바꾼 코드가 목록 \ref{code:token_method}이다.. 

\begin{codelisting} \label{code:token_method} \codecaption{토큰 생성 메서드 추가하기. 코드\\\filepath{app/models/user.rb}} 

%= lang:ruby, options: "hl_lines": [20]
\begin{code} class User < ActiveRecord::Base before_save { self.email = email.downcase } validates :name, presence: true, length: { maximum: 50 } VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false } has_secure_password validates :password, length: { minimum: 6 } 

# Returns the hash digest of the given string. def User.digest(string) cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost BCrypt::Password.create(string, cost: cost) end 

# Returns a random token. def User.new_token SecureRandom.urlsafe_base64 end end \end{code} \end{codelisting} 

사용자에 따라 기억하기 토큰을 생성하고 이를 이용해서 기억하기 다이제스트를 만들어 데이터 베이스에 저장해주는 \kode{user.remember}메서드를 만드는 것이 다음에 할 작업이다. 목록~\ref{code:add_remember_digest_to_users_generated}의 마이그레이션의 결과 사용자 모델은 이미 \kode{remember\_digest} 속성은 가지고 있지만, \kode{remember\_token} 속성은 아직 없다. 데이터베이스에 저장하지 \emph{않고} 토큰을 가져올 수 있는 \kode{user.remember\_token}(쿠키에 저장되어 있는) 메서드를 만들어야한다. 이와 비슷한 이슈는 이미 섹션~\ref{sec:adding_a_secure_password}에서 데이터 베이스에 저장되어 있는 \kode{비밀번호\_다이제스트} 속성과 가상 \kode{비밀번호} 속성을 짝으로 하여 처리하는 방식으로 다뤘었다. 이 경우에서는 가상 \kode{비밀번호} 속성은 자동으로 \kode{has\_secure\_password}이 생성해 줬지만, \kode{기억하기 \_토큰}의 경우는 수동으로 작성해야한다. 섹션 \ref{sec:a_user_class}에서 이미 봤듯이 \kode{attr\_accessor}을 이용하여 접근 가능한 속성을 생성하면 된다: 

%= lang:ruby, options: "hl_lines": [2, 7, 8]
\begin{code} class User < ActiveRecord::Base attr_accessor :remember_token . 코드. 코드. def remember self.remember_token = ... update_attribute(:remember_digest, ...) end end \end{code} 

\noindent \kode{remember} 메서드 첫번째 행의 대입의 형태를 주목하자. 루비의 객체내에서의 대입을 실행하는 방식때문에 \kode{self}없이 대입을 하면 \kode{remember\_token}라는 이름의 \emph{지역변수} 에 대입하게 된다. \kode{self}사용해서 사용자 객체의 \kode{remem\-ber\_\-token} 속성에 대입되도록 한다. (이제 목록~\ref{code:email_downcase}의 \kode{before\_save} 콜백에서 \kode{email}을 사용하지 않고 \kode{self.email}을 사용했는지 그 이유를 이제 알 수 있을 것이다.)  \kode{remember} 메서드의 두번째 행에서는 \kode{update\_attribute} 메서드를 이용해서 기억하기 다이제스트를 업데이트 했다. (섹션~\ref{sec:updating_user_objects}에서 다뤘듯이 이 메서드는 유효성 검증을 하지 않고 생략한다. 유효성 검증을 하지 않는 이유는 이 경우 사용자 객체의 비밀번호와 컨퍼메이션에 접근할 수 없기 때문이다.) 

지금까지 살펴본 사항을 염두에 두고, 이제 유효한 토큰과 이에 대응하는 다이제스트를 \kode{User.new\_\-token}메서드를 이용해서 생성할 수 있다. 그 다음 이 기억하기 다이제스트를 \kode{User.\-digest}에 저장한다. 이 과정을 수행하는 \kode{remember} 메서드 코드는 다음 목록 \ref{code:user_model_remember}과 같다. 

\begin{codelisting} \label{code:user_model_remember} \codecaption{사용자 모델에 \kode{remember} 메서드 추가하기. 코드\passing \\코드\filepath{app/models/user.rb}} 

%= lang:ruby, options: "hl_lines": [2, 26, 27]
\begin{code} class User < ActiveRecord::Base attr_accessor :remember_token before_save { self.email = email.downcase } validates :name, presence: true, length: { maximum: 50 } VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false } has_secure_password validates :password, length: { minimum: 6 } 

# Returns the hash digest of the given string. def User.digest(string) cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost BCrypt::Password.create(string, cost: cost) end 

# Returns a random token. def User.new_token SecureRandom.urlsafe_base64 end 

# Remembers a user in the database for use in persistent sessions. def remember self.remember_token = User.new_token update_attribute(:remember_digest, User.digest(remember_token)) end end \end{code} \end{codelisting} 

\subsection{로그인하면서 기억하기} \label{sec:login_with_remembering} 

% (fold)
이제 제대로 작동하는 \kode{user.remember} 메서드가 있으니 브라우저 쿠키에 영구적인 쿠키에 (암호화된)사용자 아이디와  기억하기 토큰담고 있는 유지되는 세션을 만들 차례이다. 이 작업을 하기 위해서 \kode{cookies} 메서드를 해시인것 처럼 접근하면 된다.(\kode{session}메서드와 같은 방식). 쿠키는 \kode{값}과 \kode{만료시간} 이 두개의 정보로 구성되어 있다. 예를 들어 현재부터 20년 후에 만료되는 기억하기 토큰을 쿠키에 저장하여 유지되는 세션을 만들 수 있다: 

%= lang:ruby
\begin{code} cookies[:remember_token] = { value: remember_token, expires: 20.years.from_now.utc } \end{code} 

\noindent (글상자~\ref{aside:time_helpers}에서 다뤘듯이 위 코드는 레일즈의 편리한 time 헬퍼를 이용했다.) 20년후 만료되는 쿠키는 아주 일반적인 패턴이라 레일즈에서는 이를 간단히 사용할 수 있는 \kode{permanent} 메서드를 제공한다. 

%= lang:ruby
\begin{code} cookies.permanent[:remember_token] = remember_token \end{code} 

\noindent 위와 같이 작성하면 자동으로 레일즈가 만료시간을 \kode{20.\-years.\-from\_now} 메서드를 호출하여 설정한다. 

\begin{aside} \label{aside:time_helpers} \heading{Cookies expire \texttt{20.years.from\_now}} 

섹션~\ref{sec:a_class_of_our_own}에서 언급했듯이 루비는 \emph{아무} 클래스에나 메서드를 추가할 수 있다 심지아 내장 클래스에도 가능하다. 해당 세션에서는 \texttt{String}클래스에 \texttt{palindrome?}\  메서드를 추가했었다. (그 결과 \texttt{"deified"} 가 palindrome임을 확인했다.), 또한 레일즈가 \texttt{Object}클래스에 \texttt{blank?}\  메서드를 추가한 것을 확인했다. (그래서 \texttt{"".blank?}, \texttt{"~".blank?}, \texttt{nil.blank?}\ 들이 모두 \texttt{참}이 된다). \texttt{cookies.permanent} 메서드는 ``영구적인'' 쿠키를 \texttt{20.years.from\_now}로 만료시간을 설정한다. \texttt{Fixnum} (정수의 베이스 클래스)에 추가되어 있는 레일즈의 \emph{time 헬퍼} 메서드들의 예를 좀 더 살펴 보자 : 

\begin{verbatim} $ rails console >> 1.year.from_now => Sun, 09 Aug 2015 16:48:17 UTC +00:00 >> 10.weeks.ago => Sat, 31 May 2014 16:48:45 UTC +00:00 \end{verbatim} 

\noindent 레일즈의 다른 헬퍼들도 더 있다: 

\begin{verbatim} >> 1.kilobyte => 1024 >> 5.megabytes => 5242880 \end{verbatim} 

\noindent 이 헬퍼는 파일 업로드 유효성 검증을 쉽게 할 수 있다. 예를 들어 이미지의 사이즈를 \texttt{5.megabytes}로 제한하는 식으로 사용할 수 있다. 

물론 사용하는데 주의를 요하지만, 내장 클래스에 메서드를 추가하는 기능은 루비 자체의 엄청난 유연성을 선사해준다. 물론 레일즈이 우아함은 루비 언어 자체가 가지고 있는 유연성에 그 근원을 두고 있다. 

\end{aside} 

사용자의 아이디를 쿠키에 저장하는 것은 \kode{session} 메서드을 사용하듯이(목록~\ref{code:log_in_function}) 하면 된다. 

%= lang:ruby
\begin{code} cookies[:user_id] = user.id \end{code} 

\noindent 이 코드는 사용자의 아이디를 보통 문자로 저장했기 때문에, 이 방법은 어플리케이션의 쿠키를 노출 시켜 공격자가 쉽게 사용자의 계정을 강탈할 수 있게 한다. 이를 피하기 위해서 브라우저에 저장되기 전 암호화 되는 \emph{서명된} 쿠키를 사용할 것이다: 

%= lang:ruby
\begin{code} cookies.signed[:user_id] = user.id \end{code} 

\noindent 사용자의 아이디와 영구적인 기억하기 토큰과 쌍을 이루게 하기 전에 이를 영구적으로 만들어야 하기 때문에 \kode{signed} 메서드와 \kode{permanent} 메서드를 체이닝한다: 

%= lang:ruby
\begin{code} cookies.permanent.signed[:user_id] = user.id \end{code} 

쿠키가 설정된후 추후 페이지 뷰에서 사용자를 추출하는 코드는 다음과 같다. 

%= lang:ruby
\begin{code} User.find_by(id: cookies.signed[:user_id]) \end{code} 

\noindent \kode{cookies.signed[:user\_id]}로 자동적으로 사용자 아이디\linebreak는 복호화된다. 그 다음 bcrypt을 이용하여 \kode{cookies[:remember\_token]}와 목록 \ref{code:user_model_remember}에서 생성한\kode{기억하기\_다이제스트}와 대조하여 검증한다. (기억하기 토큰 없이 바로 서명된 사용자 아이디 자체를 바로 사용하지 않는 이유가 이상할 수 있다. 만약 그렇게 하면 공격자는 암호화된 사용자 아이디 그 자체를 이용하여 로그인 할 수 있기 때문이다. 현재의 디자인대로 하면 쿠키를 가진 공격자는 실제 사용자가 로그아웃할 때까지만 로그인 할 수 있다.) 

퍼즐의 마지막 조각는 기억하기 토큰과 사용자 객체의 기억하기 토큰을 대조하여 검증하는 것 뿐이다. bcrypt를 이용하여 이를 검증하는 방법은 한 두가지 방법이 있다. \href{https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb}{secure password source code}을 살펴보면 , 다음과 같은 방법을 찾을 수 있다:\footnote{섹션~\ref{sec:a_hashed_password}에 ``unencrypted password''는 오칭이다. 왜냐면 안전한 비밀번호는 \emph{해시화 }되었지 암호화 된것이 아니기 때문이다.} 

%= lang:ruby
\begin{code} BCrypt::Password.new(password_digest) == unencrypted_password \end{code} 

\noindent 위와 같은 방법을 쓰면 다음과 같이 될 것이다: 

%= lang:ruby
\begin{code} BCrypt::Password.new(remember_digest) == remember_token \end{code} 

\noindent 가만히 이 코드를 보면 정말 이상할 것이다: 이 코드는 다이제스트를 \emph{복호화} 하지 않고 bcrypt한 비밀번호와 바로 \kode{==}연산자를 사용하여 비교하고 있기 때문이다. 하지만 bcrypt를 사용하는데 핵심을 해시화는 복원할 수 없다는 것이다. 따라서 위 코드는 틀리다. \href{https://github.com/codahale/bcrypt-ruby/blob/master/lib/bcrypt/password.rb}{bcrypt 젬 소스코드}을 직접 살펴보면 비교 연산자 \kode{==} 이 \emph{재정의}했음을 알수 있다. 따라서 실제로는 다음과 같은 연산이 이루어지게 된다: 

%= lang:ruby
\begin{code} BCrypt::Password.new(remember_digest).is_password?(remember_token) \end{code} 

\noindent \kode{==} 대신 논리형 메서드인 \kode{is\_password?}\ 으로 비교 연산했다. 이 코드가 조금 더 가독성이 높으므로, 어플리케이션 코드에서는 이를 사용하겠다. 

위에 언급한 내용에 따라 다이제스트 토큰 비교를 \kode{has\_secure\_password}을 사용하는 \kode{authenticate} 메서드와 같은 역할을 하는 사용자 모델의 \kode{authenticated?}\ 메서드에 추가 하자(목록~\ref{code:log_in_success}). 목록~\ref{code:authenticated_p}에 구현한 코드가 있다. 

\begin{codelisting} \label{code:authenticated_p} \codecaption{사용자 모델에 \kode{authenticated?}\ 메서드 추가 하기. 코드\\코드\filepath{app/models/user.rb}} 

%= lang:ruby, options: "hl_lines": [32]
\begin{code} class User < ActiveRecord::Base attr_accessor :remember_token before_save { self.email = email.downcase } validates :name, presence: true, length: { maximum: 50 } VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false } has_secure_password validates :password, length: { minimum: 6 } 

# Returns the hash digest of the given string. def User.digest(string) cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost BCrypt::Password.create(string, cost: cost) end 

# Returns a random token. def User.new_token SecureRandom.urlsafe_base64 end 

# Remembers a user in the database for use in persistent sessions. def remember self.remember_token = User.new_token update_attribute(:remember_digest, User.digest(remember_token)) end 

# 주어진 토큰과 다이제스트가 일치하면 true를 리턴한다. def authenticated?(remember_token) BCrypt::Password.new(remember_digest).is_password?(remember_token) end end \end{code} \end{codelisting} 

\noindent 목록 \ref{code:authenticated_p}의 \kode{authenticated?}\ 메서드는 기억하기 토큰과 묶여 있지만, 다른 문맥상에서도 유용할 수 있다. 이는~\ref{cha:account_activation_and_password_reset}장에서 다루도록 하겠다. 

이제 로그인한 사용자를 실제로 기억할 차례다 \kode{remember} 헬퍼를 \kode{log\_in}와 함께 실행하면 된다. 코드는 목록 \ref{code:log_in_with_remember}와 같이 될 것이다. 

\begin{codelisting} \label{code:log_in_with_remember} \codecaption{로그인하고 사용자 기억하기. 코드\\\filepath{app/controllers/sessions\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [10]
\begin{code} class SessionsController < ApplicationController 

def new end 

def create user = User.find_by(email: params[:session][:email].downcase) if user &&user.authenticate(params[:session][:password]) log_in user remember user redirect_to user else flash.now[:danger] = 'Invalid email/password combination' render 'new' end end 

def destroy log_out redirect_to root_url end end \end{code} \end{codelisting} 

\noindent 목록~\ref{code:log_in_with_remember}을 보면 \kode{log\_in}을 하면서 실제 작업은 세션 헬퍼에 정의 되어 있는 \kode{remember} 가 \kode{user.remember}을 호출하여 기억하기 토큰을 생성하고 이를 데이터베이스에 저장하게 된다. 그 다음 위에 설명 한대로 사용자의 아이디와 기억하기 토큰을 \kode{cookies}을 이용하여 영구 쿠키에 저장한다. 목록~\ref{code:remember_method}에 결과가 나타난다. 

\begin{codelisting} \label{code:remember_method} \codecaption{사용자 기억하기. 코드\\\filepath{app/helpers/sessions\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [10, 11, 12]
\begin{code} module SessionsHelper 

# Logs in the given user. def log_in(user) session[:user_id] = user.id end 

# Remembers a user in a persistent session. def remember(user) user.remember cookies.permanent.signed[:user_id] = user.id cookies.permanent[:remember_token] = user.remember_token end 

# 현재 로그인 된 사용자를 반환한다.(존재할 경우에만)def current_user @current_user ||= User.find_by(id: session[:user_id]) end 

# Returns true if the user is logged in, false otherwise. def logged_in?!current_user.nil?코드end 

# Logs out the current user. def log_out session.delete(:user_id) @current_user = nil end end \end{code} \end{codelisting} 

목록 \ref{code:remember_method}의 코드로 사용자가 로그인하면 유효한 기억하기 토큰을 브라우저에 저장하지만, 이는 아직 아무런 역할을 하지 못한다. 왜냐면 목록 \ref{code:current_user}의 \kode{current\_user} 메서드가 아직 임시 세션만 참조 하고 있기 때문이다: 

%= lang:ruby
\begin{code} @current_user ||= User.find_by(id: session[:user_id]) \end{code} 

\noindent 유지되는 세션의 경우 \kode{session[:user\_id]}가 존재하면 여기서 사용자를 찾고 그렇지 않으면 \kode{cookies[:user\_id]}에서 사용자를 찾아(로야그인 시키고)한다. 이를 성취하기 위해서 다음 코드가 필요하다: 

%= lang:ruby
\begin{code} if session[:user_id] @current_user ||= User.find_by(id: session[:user_id]) elsif cookies.signed[:user_id] user = User.find_by(id: cookies.signed[:user_id]) if user &&user.authenticated?(cookies[:remember_token]) log_in user @current_user = user end end \end{code} 

\noindent (이 방법은 목록 \ref{code:find_authenticate_user}에서 사용한 \kode{user \&\& user.authenticated} 패턴과 같은 방식이다.) 위 코드는 일단은 작동하지만, 반복적으로 \kode{session} 과 \kode{cookies}을 사용한다. 중보를 다음과 같이 제거할 수 있다: 

%= lang:ruby, options: "hl_lines": [1, 3]
\begin{code} if (user_id = session[:user_id]) @current_user ||= User.find_by(id: user_id) elsif (user_id = cookies.signed[:user_id]) user = User.find_by(id: user_id) if user &&user.authenticated?(cookies[:remember_token]) log_in user @current_user = user end end \end{code} 

\noindent 여기서 일반적이지만 잠재적으로 혼란을 야기할 수 있는 구조를 사용했다 

%= lang:ruby
\begin{code} if (user_id = session[:user_id]) \end{code} 

\noindent 겉으로 봐서는 이것은 비교 연산이(이퀄 두개\kode{==}를 사용하는)\emph{아니고 }\emph{대입}연산이다. 말로 바꿔서 생각해보면, ``만약 사용자의 아이디가 세션의 사용자 아이디와 같으면 \ldots''이 아니라 ``만약 사용자 아이디가 세션에 존재한다면(사용자 아이디를 세션의 사용자 아이디로 설정하면)\ldots''으로 생각할 수 있다.\footnote{디나는 비교 연산이 아니라 대입을 괄호안에 사용하는 관습을 시각적인 표현으로써 사용한다.} 

위에 살펴본 \kode{current\_user} 헬퍼의 구현된 모습은 목록 \ref{code:persistent_current_user}과 같다. 

\begin{codelisting} \label{code:persistent_current_user} \codecaption{ \kode{current\_user}을 유지되는 세션에 업데이트 하기코드\failing \\\filepath{app/helpers/sessions\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [17, 18, 19, 20, 21, 22, 23, 24, 25]
\begin{code} module SessionsHelper 

# Logs in the given user. def log_in(user) session[:user_id] = user.id end 

# Remembers a user in a persistent session. def remember(user) user.remember cookies.permanent.signed[:user_id] = user.id cookies.permanent[:remember_token] = user.remember_token end 

# Returns the user corresponding to the remember token cookie. def current_user if (user_id = session[:user_id]) @current_user ||= User.find_by(id: user_id) elsif (user_id = cookies.signed[:user_id]) user = User.find_by(id: user_id) if user &&user.authenticated?(cookies[:remember_token]) log_in user @current_user = user end end end 

# Returns true if the user is logged in, false otherwise. def logged_in?!current_user.nil?코드end 

# Logs out the current user. def log_out session.delete(:user_id) @current_user = nil end end \end{code} \end{codelisting} 

목록~\ref{code:persistent_current_user}코드로 새롭게 로그인한 사용자는 자동으로 기억된다. 이는 로그인한 다음 브라우저를 닫았다 연다음 다시 어플리케이션에 접속해서 아직 로그인 되어 있는지 확인하는 방법으로 확인하면 된다. 원한다면 브라우저 인스펙터를 열어서 브라우저 쿠키를 확인해 볼 수 있다.(그림~\ref{fig:cookie_in_browser}).\footnote{``<your browser name> 쿠키 확인하기''을 구글에서 검색하여 시스템에 쿠키를 어떻게 확인하는지 찾아보자.} 

\begin{figure} \begin{center} \imagebox{images/figures/cookie_in_browser_chrome.png} \end{center} \caption{브라우저에 저장되어 있는 기억하기 토큰.\label{fig:cookie_in_browser}} \end{figure} 

이제 어플리케이션에는 하나의 문제만 남아있다: 브라우저의 쿠키를 제거해서 로그아웃을 하는 것(현재는 20년을 기다려야함)이런 상황이 테스트 스위트가 잡아내야하는 것이고 실제로 테스트 스위트의 결과는 \failing이다: 

\begin{codelisting} \codecaption코드{\failing} 

%= lang:text
\begin{code} 코드$ bundle exec rake test \end{code} \end{codelisting} 

% subsection login_with_remembering (end)
\subsection{사용자 잊기} \label{sec:forgetting_users} 

% (fold)
사용자가 로그아웃할 수 있게 하려면 사용자를 기억하는 것과 쌍으로 그것을 잊는 메서드를 정의해야 한다. \kode{user.forget} 메서드는 \kode{user.remember}가 저장한 기억하기 다이제스트를 \kode{nil} 설정하여 하는 것이다. 코드는 다음 목록 \ref{code:user_model_forget}과 같다. 

\begin{codelisting} \label{code:user_model_forget} \codecaption{사용자 모델에 \kode{forget} 메서드 추가 하기. 코드\\코드\filepath{app/models/user.rb}} 

%= lang:ruby, options: "hl_lines": [37]
\begin{code} class User < ActiveRecord::Base attr_accessor :remember_token before_save { self.email = email.downcase } validates :name, presence: true, length: { maximum: 50 } VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i validates :email, presence: true, length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX }, uniqueness: { case_sensitive: false } has_secure_password validates :password, length: { minimum: 6 } 

# Returns the hash digest of the given string. def User.digest(string) cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost BCrypt::Password.create(string, cost: cost) end 

# Returns a random token. def User.new_token SecureRandom.urlsafe_base64 end 

# Remembers a user in the database for use in persistent sessions. def remember self.remember_token = User.new_token update_attribute(:remember_digest, User.digest(remember_token)) end 

# 주어진 토큰과 다이제스트가 일치하면 true를 리턴한다. def authenticated?(remember_token) BCrypt::Password.new(remember_digest).is_password?(remember_token) end 

# Forgets a user. def forget update_attribute(:remember_digest, nil) end end \end{code} \end{codelisting} 

목록 \ref{code:user_model_forget}코드에 있는 \kode{forget} 헬퍼를 \kode{log\_out} 헬퍼(목록 \ref{code:log_out_with_forget})에서 호출하여 영구적인 세션을 지울 준비가 끝났다. 목록 \ref{code:log_out_with_forget}에서 보듯이, \kode{forget} 헬퍼는 \kode{user.forget} 을 호출하여 \kode{user\_id}와 \kode{remember\_\-token}값을 쿠키에서 삭제한다. 

\begin{codelisting} \label{code:log_out_with_forget} \codecaption{유지되는 세션 로그아웃하기코드\\\filepath{app/helpers/sessions\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [12, 13, 14, 19]
\begin{code} module SessionsHelper 

# Logs in the given user. def log_in(user) session[:user_id] = user.id end . 코드. 코드. # Forgets a persistent session. def forget(user) user.forget cookies.delete(:user_id) cookies.delete(:remember_token) end 

# Logs out the current user. def log_out forget(current_user) session.delete(:user_id) @current_user = nil end end \end{code} \end{codelisting} 

% subsection forgetting_users (end)
\subsection{두개의 미묘한 버그} \label{sec:two_subtle_bugs} 

% (fold)
이 두가지 문제는 미묘하게 남아 있는 링크들에 밀접하게 연관이 있다. 첫번째 버그는, 사용자가 ``로그 아웃''링크는 오직 로그인 사용자에게만 노출 시키더라도, 잠재적으로 여러개의 브라우저 윈도우로 어플리케이션으 열어 놓을 수 있다. 만약 사용자가 하나의 윈도우에서 로그아웃을 하고, 다른 윈도우에 아직 있는 ``Log out'' 링크를 클릭했을때 목록 \ref{code:log_out_with_forget}에서 \kode{current\_user}을 사용하고 있기때문에 에러가 발생한다.\footnote{독자 Paulo Célio Júnior가 이 문제을 지적해 줬다.} 이 문제는 오직 로그인했을때만 로그아웃할 수 있게 함으로 고칠 수 있다. 

두번째 문제는 사용자는 크롬과 파이어폭스등 동시에 여러개의 브라우저에서 로그인(기억하기까지)할 수 있다. 문제는 하나의 브라우저에서는 로그아웃하고 다른 하나에서는 하지 않았을때 발생한다.\footnote{독자 Niels de Ron이 이 문제를 지적해 줬다.} 예를 들면 파이어 폭스에서 로그아웃을 해서 기억하기 다이제스트\kode{nil}로 바뀌었다고 하자(\kode{목록~\ref{code:user_model_forget}의 user.forget} ). 파이어폭스에서는 계속 작동하게 된다. 그 이유는 목록 \ref{code:log_out_with_forget}의 \kode{log\_out} 메서드에서 사용자의 아이디를 삭제했기 때문에 \kode{user} 변수는 \kode{current\_user} 메서드에서 \kode{nil}이 된다. 

%= lang:ruby, options: "hl_lines": [6]
\begin{code} # Returns the user corresponding to the remember token cookie. def current_user if (user_id = session[:user_id]) @current_user ||= User.find_by(id: user_id) elsif (user_id = cookies.signed[:user_id]) user = User.find_by(id: user_id) if user &&user.authenticated?(cookies[:remember_token]) log_in user @current_user = user end end end \end{code} 

\noindent 결과적으로 다음 표현식 

%= lang:ruby
\begin{code} user &&user.authenticated?(cookies[:remember_token]) \end{code} 

\noindent \kode{false}을 리턴하는 닫힌 회로 조건식이 된다. (왜냐면 \kode{user}  는\kode{nil}이기 때문에 논리형 연산에서 \kode{false}이고 두번째 표현식을 평가하지 않기 때문이다.) 반면에 크롬에서는 사용자 아이디는 지워지지 \emph{않아서}, \kode{user} 가 \kode{nil}이 아니게 된다. 

%= lang:ruby
\begin{code} user &&user.authenticated?(cookies[:remember_token]) \end{code} 

\noindent 그리고 두번째 표현식이 평가된다. 다시 말해서 \kode{auth\-en\-ti\-ca\-ted?}\ 메서드를 호출하게 된다.(목록~\ref{code:authenticated_p}) 

%= lang:ruby
\begin{code} def authenticated?(remember_token) BCrypt::Password.new(remember_digest).is_password?(remember_token) end \end{code} 

\noindent \kode{기억하기\_다이제스트} 는 \kode{nil} 이라서 \kode{BCrypt::Password.\-new(remember\_\-digest)}을 호출할 때 에러를 발생시킨다. 위와 같은 상황말고 \kode{authenticated?}\ 은 \kode{false} 반환해야 한다. 

이런 문제는 정확하게 테스트 주도 개발을 통해 얻을 수 잡을 수 있는 문제들이다. 우선 이 두개의 에러를 고치는 코드를 작성하기 전에 이를 테스트하는 테스트를 먼저 작성해보자. 목록 \ref{code:test_double_logout}과 같이 \ref{code:user_logout_test}을 변경하면 통합 테스트의 결과가 \failing이 된다.. 

\begin{codelisting} \label{code:test_double_logout} \codecaption{로그아웃 테스트. 코드\failing \\\filepath{test/integration/users\_login\_test.rb}} 

%= lang:ruby, options: "hl_lines": [20, 21]
\begin{code} 코드require 'test_helper' 

class UsersLoginTest < ActionDispatch::IntegrationTest . 코드. 코드. test "login with valid information followed by logout" do get login_path post login_path, session: { email: @user.email, password: 'password' } assert is_logged_in?assert_redirected_to @user follow_redirect!assert_template 'users/show' assert_select "a[href=?]", login_path, count: 0 assert_select "a[href=?]", logout_path assert_select "a[href=?]", user_path(@user) delete logout_path assert_not is_logged_in?assert_redirected_to root_url # Simulate a user clicking logout in a second window. delete logout_path follow_redirect!assert_select "a[href=?]", login_path assert_select "a[href=?]", logout_path, count: 0 assert_select "a[href=?]", user_path(@user), count: 0 end end \end{code} \end{codelisting} 

\noindent 목록 \ref{code:test_double_logout}의 두번째로 호출한 \kode{delete logout\_path}은 이미 삭제된 \kode{current\_user}때문에 에러를 발생시키고 테스트 결과가 \failing\  이 된다: 

\begin{codelisting} \codecaption코드{\failing} 

%= lang:text
\begin{code} 코드$ bundle exec rake test \end{code} \end{codelisting} 

어플리케이션 코드는 간단히 \kode{logged\_\-in?}이 참일때만 \kode{log\_out}이 호출되도록 목록 \ref{code:destroy_forget}과 같이 고치면 된다. 

\begin{codelisting} \label{code:destroy_forget} \codecaption{로그인한 상태만 로그아웃 시키기. 코드\passing \\\filepath{app/controllers/sessions\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [6]
\begin{code} class SessionsController < ApplicationController . 코드. 코드. def destroy log_out if logged_in?redirect_to root_url end end \end{code} \end{codelisting} 

두번째 경우 두개의 다른 브라우져일 경우 통합테스트로 테스트하기 어렵다. 그러나 사용자 모델에서 바로 테스트 하는 것이 훨씬 쉽다. 우선 기억하기 다이제스트가 없는 사용자부터 준비한다.(이것은 \kode{setup}메서드에서 \kode{@user} 변수을 정의해서 할 수 있다) 그리고 \kode{authenticated?}을 호출 한다(목록~\ref{code:test_authenticated_invalid_token}). (기억하기 토큰이 비어있지만, 현재는 상관없다. 왜냐면 이 속성이 사용되기 이전에 에러가 발생하기 때문이다.) 

\begin{codelisting} \label{code:test_authenticated_invalid_token} \codecaption{다이제스트가 없는 상태에서 \kode{authenticated?}\ 테스트코드\failing \\\filepath{test/models/user\_test.rb}} 

%= lang:ruby
\begin{code} 코드require 'test_helper' 

class UserTest < ActiveSupport::TestCase 

def setup @user = User.new(name: "Example User", email: "user@example.com", password: "foobar", password_confirmation: "foobar") end . 코드. 코드. test "authenticated?should return false for a user with nil digest" do assert_not @user.authenticated?('') end end \end{code} \end{codelisting} 

\kode{BCrypt::Password.new(nil)}는 에러를 발생키기 때문에 테스트 스위트의 결과는 \failing이다: 

\begin{codelisting} \codecaption코드{\failing} 

%= lang:text
\begin{code} 코드$ bundle exec rake test \end{code} \end{codelisting} 

이를 고쳐서 \passing 결과를 얻기 위해서는, 목록 \ref{code:authenticated_p_fixed}와 같이 기억하기 다이제스트가 \kode{nil}일때 \kode{false}을 반환하도록 하면 된다. 

\begin{codelisting} \label{code:authenticated_p_fixed} \codecaption{존재하지 않는 다이제스트를 다루기 위해 \kode{authenticated?}\ 을 수정하기. 코드\passing \\\filepath{app/models/user.rb}} 

%= lang:ruby, options: "hl_lines": [7]
\begin{code} 코드class User < ActiveRecord::Base . 코드. 코드. # 주어진 토큰과 다이제스트가 일치하면 true를 리턴한다. def authenticated?(remember_token) return false if remember_digest.nil?BCrypt::Password.new(remember_digest).is_password?(remember_token) end end \end{code} \end{codelisting} 

\noindent 이 코드는 \kode{return} 키워드를 사용하여 기억하기 다이제스트가 \kode{nil}이면 즉시 거짓을 반환하도록 하였다. 이 방법은 특정 조건에서 이 후 코드가 무시된다는 것을 강조해주는 일반적인 방법이다. 다른 해결법 

%= lang:ruby
\begin{code} if remember_digest.nil? false else BCrypt::Password.new(remember_digest).is_password?(remember_token) end \end{code} 

\noindent 이 코드도 잘 동작하지만 목록~\ref{code:authenticated_p_fixed}의 방식을 저자 본인은 더 선호한다.  (또한 약간 더 짧기도 하다). 

목록 \ref{code:authenticated_p_fixed}의 코드로 테스트 스위트의 결과는 \passing이 되었다. 자 두개의 버그가 모두 해결되었다: 

\begin{codelisting} \codecaption코드{\passing} 

%= lang:text
\begin{code} 코드$ bundle exec rake test \end{code} \end{codelisting} 

% subsection two_subtle_bugs (end)
\subsection{``remember me'' 체크박스} \label{sec:remember_me_checkbox} 

% (fold)
섹션~\ref{sec:forgetting_users}의 코드 까지 추가됨으로 우리의 어플리케이션은 전문가 수준의 인증 시스템을 갖추었다. 마지막 단계로 ``remember me''체크 박스로 선택적으로 로그인 상태를 유지할 것인지 선택할 수 있게 할 것이다. 로그인 폼의 목업은 그림 \ref{fig:login_remember_me_mockup}과 같다. 

\begin{figure} \begin{center} \imagebox{images/figures/login_remember_me_mockup.png} \end{center} \caption{``remember me''체크 박스 목업.\label{fig:login_remember_me_mockup}} \end{figure} 

이를 구현하기 위해서 우선 목록 \ref{code:login_form}에 체크박스를 넣자. 라벨, 텍스트 필드, 비밀번호 필드 서밋 버튼처럼 체크박스도 레일즈 헬퍼로 생성할 수 있다. 제대로 된 스타일을 위해서 다음과 같이 라벨의 \emph{안쪽에} 체크박스를 넣어야 한다: 

%= lang:rhtml
\begin{code} < < <span>이 컴퓨터에서 기억하기</span> < \end{code} 

%= f.label :remember_me, class: "checkbox inline" do %>%= f.check_box :remember_me %>% end %>
\noindent 목록 \ref{code:remember_me_checkbox}의 코드를 로그인 폼에 넣기. 

\begin{codelisting} \label{code:remember_me_checkbox} \codecaption{로그인 폼에 ``remember me'' 체크박스 넣기. 코드\\\filepath{app/views/sessions/new.html.erb}} 

%= lang:rhtml, options: "hl_lines": [14, 15, 16, 17]
\begin{code} < <h1>로그인</h1> 

% provide(:title, "Log in") %>
<div class="row"> <div class="col-md-6 col-md-offset-3"> < 

%= form_for(:session, url: login_path) do |f| %>
< < 

%= f.label :email %>%= f.email_field :email, class: 'form-control' %>
< < 

%= f.label :password %>%= f.password_field :password, class: 'form-control' %>
< < <span>이 컴퓨터에서 기억하기</span> < 

%= f.label :remember_me, class: "checkbox inline" do %>%= f.check_box :remember_me %>% end %>
< < 

%= f.submit "Log in", class: "btn btn-primary" %>% end %>
<p>새로운 사용자이신가요?< </div> </div> \end{code} \end{codelisting} 

%= link_to "Sign up now!", signup_path %></p>
목록 \ref{code:remember_me_checkbox}에서 Bootstrap CSS 클래스\kode{checkbox}와 \kode{inline}을 넣었다. 그리고 같은 라인에 문자열(``Remember me on this computer'')도 넣었다. 스타일을 완성하기 위해서 목록 \ref{code:remember_me_css}과 같이 CSS를 약간 추가했다. 이를 통해서 화면은 그림 \ref{fig:login_form_remember_me}이 구성된다. 

\begin{codelisting} \label{code:remember_me_css} \codecaption{``remember me'' 체크 박스 CSS. 코드\\코드\filepath{app/assets/stylesheets/custom.css.scss}} 

%= lang:scss
\begin{code} 코드. 코드. 코드. 코드/* forms */ . 코드. 코드. .checkbox { margin-top: -10px; margin-bottom: 10px; span { margin-left: 20px; font-weight: normal; } } 

#session_remember_me { width: auto; margin-left: 0; } \end{code} \end{codelisting} 

\begin{figure} \begin{center} \image{images/figures/login_form_remember_me.png} \end{center} \caption{``remember me'' 체크박스가 추가된 로그인 폼.\label{fig:login_form_remember_me}} \end{figure} 

이렇게 로그인 폼을 고쳐서 체크박스가 체크되면 사용자를 기억하고 그렇지 않으면 사용자를 잊는 기능을 완성했다. 놀랍게도 이 섹션에서 한 작업들을 통해서 실제 구현은 단지 한 줄의 코드로 끝난다. 서브밋 로그인 폼의 \kode{params} 해시는 체크 박스의 값을 포함하게 된다. (목록 \ref{code:remember_me_checkbox}에서 서밋된 내용을 디버그 섹션에서 확인할 수 있다). 다음 값 

%= lang:ruby
\begin{code} params[:session][:remember_me] \end{code} 

\noindent 은 체크 되었을 경우 \kode{'1'} 그렇지 않을 경우 \kode{'0'}이 된다. 

서밋된 값인 \kode{params} 해시값을 확인하여 사용자를 기억하거나 잊거나 할 수 있다: 

%= lang:ruby
\begin{code} if params[:session][:remember_me] == '1' remember(user) else forget(user) end \end{code} 

\noindent 글 상자\ref{aside:ternary_operator}에서 이미 설명했듯이, \kode{if}-\kode{then} 브랜치 구조는 \emph{삼항 연산자}을 이용하여 한 줄로 다음과 같이 줄일 수 있다:\footnote{\kode{remember user을 작성하기 전에} 괄호가 없이 삼항 연산자를 사용하면 문법 에러를 발생시킨다.} 

%= lang:ruby
\begin{code} params[:session][:remember_me] == '1' ? remember(user) : forget(user) \end{code} 

\noindent 이 라인을 세션 컨트롤러의 \kode{create} 메소드에 추가함으로써 너무나도 간단하게 목록 \ref{code:remember_me_ternary}과 같이 해결할 수 있다. (이번엔 bcrypt \kode{cost} 변수를 이용한 삼항 연산자를 사용한 \ref{code:digest_method}의 코드를 이해할 차례다) 

\newpage

\begin{codelisting} \label{code:remember_me_ternary} \codecaption{``remember me'' 체크 박스 서밋 처리하기. 코드\\\filepath{app/controllers/sessions\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [10]
\begin{code} class SessionsController < ApplicationController 

def new end 

def create user = User.find_by(email: params[:session][:email].downcase) if user &&user.authenticate(params[:session][:password]) log_in user params[:session][:remember_me] == '1' ? remember(user) : forget(user) redirect_to user else flash.now[:danger] = 'Invalid email/password combination' render 'new' end end 

def destroy log_out if logged_in? redirect_to root_url end end \end{code} \end{codelisting} 

\noindent 목록 \ref{code:remember_me_ternary}의 코드로 로그인 시스템은 완성되었다. 브라우저에서 체크박스를 체크했다가 풀었다 하여 이를 테스트 해볼 수 있다. 

\begin{aside} \label{aside:ternary_operator} \heading{10가지 타입의 사람들} 

세상에는 10가지 타입의 사람이 존재한다: 2진법을 이해하는 사람과 그렇지 않은 사람 이라는 유명한 농담이 있다.(당연히 10은 이진법으로 2이다). 같은 맥락에서 세상에는 10가지 타입의 사람이 있다: 삼항 연산자를 좋아하는 사람과 그렇지 않은 사람 또는 아직 모르는 사람. (만약 당신이 세번째 분류에 들어간다면, 이제는 더이상 모르는 사람이 아니다.) 

프로그래밍을 계속 해왔다면, 다음과 같은 일반적인 흐름제어법을 접하게 될 것이다: 

\begin{verbatim} if boolean? do_one_thing else do_something_else end \end{verbatim} 

\noindent 루비를 포함한 많은 언어(C/C++, Perl, PHP, and Java)들이 위 표현을 짧게 표현할 수 있는 \emph{삼항 연산자}을 제공한다. (세개의 부분으로 이루어져 있어서): 

\begin{verbatim} boolean? ? do_one_thing : do_something_else \end{verbatim} 

\noindent 삼항 연산자는 대입 연산으로 변경하여 사용할 수 도 있다. 

\begin{verbatim} if boolean? var = foo else var = bar end \end{verbatim} 

\noindent 는 보간이 끝난 후 

\begin{verbatim} var = boolean? ? foo : bar \end{verbatim} 

\noindent 마지막으로 삼항 연사자는 함수의 반환값에 사용해도 편리하다. 

\begin{verbatim} def foo do_stuff boolean? ? "bar" : "baz" end \end{verbatim} 

\noindent 루비는 암묵적으로 함수의 마지막 표현식이 반환되므로 \texttt{foo} 메서드는 \texttt{boolean?}\ 이 \texttt{참}이냐 \texttt{거짓이냐}에 따라 \texttt{"bar"}나 \texttt{"baz"}을 반환한다. 

\end{aside} 

\subsection{기억하기 테스트} \label{sec:remember_tests} 

% (fold)
비로 ``remember me"기능이 제대로 동작하고 있지만, 이 동작을 검증하는 테스트를 작성하는 것은 중요하다. 잠깐 언급했듯이 구현하는 과저에서 발생할 수 있는 에러를 잡기 위함이다. 하지만 이보다 더 중요한 이유는 사용자 영속성 코어가 전혀 테스트 되고 있지 않기 때문이다. 이 문제를 해결하는 것은 조금 어려울 수 있지만, 해결된다면 테스트 스위트가 훨씬 강력해 질 수 있다. 

\subsubsection{``remember me'' 체크박스 테스트하기} \label{sec:testing_the_remember_me_box} 

% (fold)
처음에 체크박스를 구현했을때 \ref{code:remember_me_ternary}, 다음과 같은 코드를 작성하지 못했다. 

%= lang:ruby
\begin{code} params[:session][:remember_me] == '1' ? remember(user) : forget(user) \end{code} 

\noindent 실제로는 다음 코드를 사용했었다. 

%= lang:ruby
\begin{code} params[:session][:remember_me] ? remember(user) : forget(user) \end{code} 

\noindent \kode{params[:session][:remember\_me]}이 \kode{'0'} 이든 \kode{'1'}이든 논리형 연산에서 둘다 \kode{참}이다. 그래서 이 표현식의 결과는 \emph{항상 참}이다. 그래서 어플리케이션은 체크박스가 항상 체크된것 처럼 동작하게 된다. 이런 케이스가 테스트가 잡아낼 수 있는 전형적인 상황이다. 

사용자 기억하기는 사용자가 일단 로그인을 해야하기 때문에 이를 테스트 하는 헬퍼 안에 정의 하면 된다. 목록~\ref{code:user_login_test_valid_information}에서 보듯이 사용자를 로그인 시키는데 \kode{post} 메서드로 유효한 \kode{session} 해시을 사용한다. 하지만 이를 매번하는 것은 귀찮은 일이다. 이런 무의미한 반복을 하지 않기 위해서, 로그인을 해주는 \kode{log\_in\_as} 헬퍼를 만들겠다. 

사용자 로그인 메서드는 다른 타입의 테스트에 의존하게 된다. 통합 테스트에서 목록 \ref{code:user_login_test_valid_information}와 같이 세션 경로로 post 요청을 보낼 수 있다. 그러나 다른 테스트에서는 그렇지 않다.( 컨트롤러나 모델 테스트에서) 따라서 \kode{session} 메서드를 직접 조작해야한다. 결론적으로 \kode{log\_in\_as}은 이를 사용하는 테스트의 타입에 따라서 조금씩 다르게 동작해야 한다. 통합 테스트와 다른 종류의 테스트의 구별은 루비의 편리한 \kode{defined?}\ 메서드를 이용하여 알아낼 수 있다. 이 메서드는 인자가 정의 되어 있으면 참, 그렇지 않으면 거짓을 반환한다. 현재의 경우에 \kode{post\_via\_redirect} 메서드 (목록 \ref{code:a_test_for_valid_submission})은 오직 통합 테스트에서만 사용할 수 있다. 

%= lang:ruby
\begin{code} defined?(post_via_redirect) ... \end{code} 

\noindent 위 표현은 통합 테스트에서는 \kode{참}, 다른 곳에서는 거짓을 반환한다. 이는 \kode{integration\_test?}\ 논리형 메서드를 if-then문을 이용하여 도식적으로 다음과 같이 작성하면 됨을 시사한다: 

%= lang:ruby
\begin{code} if integration_test? # Log in by posting to the sessions path else # Log in using the session end \end{code} 

\noindent 주석부분을 채우면 \kode{log\_in\_as} 헬퍼 메소드를 목록 \ref{code:test_helper_log_in}과 같이 완성할 수 있다.. (이 메서드는 굉장히 높은 수준의 메서드이다. 따라서 다음 코드를 읽고 이해할 수 있다면 아주 잘 하고 있는 것이다.) 

\begin{codelisting} \label{code:test_helper_log_in} \codecaption{\kode{log\_in\_as} 헬퍼 추가 하기. 코드\\\filepath{test/test\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [17, 30]
\begin{code} ENV['RAILS_ENV'] ||= 'test' . 코드. 코드. class ActiveSupport::TestCase fixtures :all 

# Returns true if a test user is logged in. def is_logged_in?!session[:user_id].nil?코드end 

# Logs in a test user. def log_in_as(user, options = {}) password = options[:password] || 'password' remember_me = options[:remember_me] || '1' if integration_test? post login_path, session: { email: user.email, password: password, remember_me: remember_me } else session[:user_id] = user.id end end 

private 

# Returns true inside an integration test. def integration_test? defined?(post_via_redirect) end end \end{code} \end{codelisting} 

\noindent 유연성을 더하기 위해서 목록 \ref{code:test_helper_log_in}의 \kode{log\_in\_as} 메서드는 \kode{options} 해시를 (목록~\ref{code:gravatar_option}에서 처럼)을 받아 디폴트 비밀번호와 ``remember me'' 체크박스를 각각 \kode{'password'}와 \kode{'1'}로 설정하도록 했다. 해시는 존재하지 않는 키에 대해서 \kode{nil}을 반환하기 때문에 다음 코드는 

%= lang:ruby
\begin{code} remember_me = options[:remember_me] || '1' \end{code} 

\noindent 옵션이 주어지만 이 값으로 설정되고 그렇지 않을 경우 디폴트 값으로 설정되게 된다. (글상자\ref{aside:or_equals}에서 설명한 닫힌 회로 평가식). 

 ``remember me'' 체크박스의 동작을 검증하기 위해서 두 개의 테스트를 작성할 것이다. 하나는 체크박스를 체크해서 서밋하고 나머지는 체크하지 않고 서밋하도록 한다. 목록 \ref{code:test_helper_log_in}에 정의된 로그인 헬퍼를 사용하는 것은 쉽다. 두 케이스는 다음과 같다 

%= lang:ruby
\begin{code} log_in_as(@user, remember_me: '1') \end{code} 

\noindent 그리고 

%= lang:ruby
\begin{code} log_in_as(@user, remember_me: '0') \end{code} 

\noindent (\kode{'1'}은 \kode{remember\_me}의 기본값이므로 첫번째 케이스에서 이 옵션을 생략할 수 있지만 그러지 않았다. 이를 넣어주는 것이 대응 쌍구조로 더 이가시적이기 때문이다.) 

로그인을 한 다음 \kode{remember\_token} 키가 \kode{cookies}에 있는지 확인하여 기억됐는지 확인할 수 있다. 쿠키의 값과 사용자의 기억하기 토큰값이 서로 같은지 확인하는것이 가장 이상적이지만, 현재 구조상 테스트에서 이에 접근할 수 있는 방법이 없다: 컨트롤러 내에 있는 \kode{user} 변수는 기억하기 토큰 속성을 가지고 있지만 테스트내에 \kode{@user} 변수는 가지고 있지 않다(\kode{remember\_token}은 가상의 값이기 때문에). 이 작은 부분을 고치는 것은 연습문제로 남겨 놓았다. (섹션~\ref{sec:log_in_out_exercises}), 현재로써는 쿠키값이 {nil}인지 아닌지만 테스트 하도록 하겠다. 

하나 더 미묘한 문제가 있다. 그것은 어떤 이유로 테스트 내에서는 심벌을 키로 쿠키 메서드에 접근하는 것이 동작하지 않는다. 

%= lang:ruby
\begin{code} cookies[:remember_token] \end{code} 

\noindent 은 항상 \kode{nil}이다. 다행이도 \kode{cookies} \emph{는 문자열 키로는 동작한다.} 

%= lang:ruby
\begin{code} cookies['remember_token'] \end{code} 

\noindent 위 표현으로 우리가 원하는 값에 접근할 수 있다. 결과적으로 목록 \ref{code:remember_me_test}과 같이 될 것이다. (목록~\ref{code:user_login_test_valid_information}에서 \kode{users(:michael)}이 목록 \ref{code:real_user_fixture}의 사용자 픽스쳐를 참고하는 상기해보자.) 

\begin{codelisting} \label{code:remember_me_test} \codecaption{``remember me'' 체크박스 테스트. 코드\passing \\\filepath{test/integration/users\_login\_test.rb}} 

%= lang:ruby, options: "hl_lines": [12, 13, 17, 18]
\begin{code} 코드require 'test_helper' 

class UsersLoginTest < ActionDispatch::IntegrationTest 

def setup @user = users(:michael) end . 코드. 코드. test "login with remembering" do log_in_as(@user, remember_me: '1') assert_not_nil cookies['remember_token'] end 

test "login without remembering" do log_in_as(@user, remember_me: '0') assert_nil cookies['remember_token'] end end \end{code} \end{codelisting} 

\noindent 여러분이 저자와 똑같은 구현상에 실수를 하지 않았다면 테스트 결과 \passing이 될 것이다.: 

\begin{codelisting} \codecaption코드{\passing} 

%= lang:text
\begin{code} 코드$ bundle exec rake test \end{code} \end{codelisting} 

% subsubsection testing_the_remember_me_box (end)
\subsubsection{기억하기 브랜치 테스트하기} \label{sec:testing_the_remember_branch} 

% (fold)
섹션 \ref{sec:login_with_remembering}에서 구현한 코드는 손으로 잘 동작하는지 테스트는 했지만,  사실 \kode{current\_user} 메서드는 현재 전혀 테스트되고 있지 않다. 이런 상황을 타개하는 저자 본인이 가장 개인적으로 가장 선호하는 방법은 테스트가 안되고 있는것으로 의심되는 코드 블럭에서 예외를 발생시키는 것이다: 만약 코드가 테스트되고 있지 않으면 테스트는 계속 통과하고 그렇지 않으면 해당하는 테스트에 대해서 에러를 발생시킨다. 현재 상황의 해결방법이 목록\ref{code:branch_raise}에 있다.. 

\begin{codelisting} \label{code:branch_raise} \codecaption{테스트 되지 않은 브랜치에서 예외 발생시키기코드\passing \\\filepath{app/helpers/sessions\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [10]
\begin{code} module SessionsHelper . 코드. 코드. # Returns the user corresponding to the remember token cookie. def current_user if (user_id = session[:user_id]) @current_user ||= User.find_by(id: user_id) elsif (user_id = cookies.signed[:user_id]) raise # The tests still pass, so this branch is currently untested. user = User.find_by(id: user_id) if user &&user.authenticated?(cookies[:remember_token]) log_in user @current_user = user end end end . 코드. 코드. 코드end \end{code} \end{codelisting} 

\noindent 현재 시점에서 테스트 결과는 \passing이다: 

\begin{codelisting} \codecaption코드{\passing} 

%= lang:text
\begin{code} 코드$ bundle exec rake test \end{code} \end{codelisting} 

\noindent 이것은 큰 문제다 실은 목록 \ref{code:branch_raise}의 코드는 망가져 있기 때문이다. 게다가 유지되는 세션은 손으로 테스트하기 귀찮다. 따라서 \kode{current\_user} 메서드를 리팩토링 해서 테스트 하는것은 중요하다. (\ref{cha:account_activation_and_password_reset}장에서 다루게 될 것이다). 

목록 \ref{code:test_helper_log_in}에서 정의한 \kode{log\_in\_as} 헬퍼 메서드가 자동으로 \kode{session[:user\_id]}을 설정해 주기 때문에,  ``remember'' 브랜치의 \kode{cur\-rent\_user} 메서드를 통합테스트에서 테스트하기 어렵다. 다행히 이 제한을 세션 헬퍼 테스트를 만들어서 직접 \kode{current\_user} 메서드를 테스트 하면 이 제약사항을 피할 수 있다: 

%= lang:console
\begin{code} $ touch test/helpers/sessions_helper_test.rb \end{code} 

\noindent 테스트 시퀀스는 간단하다: 

\begin{enumerate} \item 픽스처를 이용하여 \kode{user} 변수를 정의한다. \item \kode{remember} 메서드를 호출하여 사용자를 기억시킨다. \item \kode{current\_user}가 주어진 사용자와 같은지 검증한다. \end{enumerate} 

\noindent \kode{remember} 메서드는 \kode{session[:user\_id]}을 설정하지 않기 때문에 이 방법이 ``remember'' 브랜치를 테스트하는데 적당하다. 목록~\ref{code:persistent_sessions_test}에 결과가 나와있다. 

\begin{codelisting} \label{code:persistent_sessions_test} \codecaption{유지되는 세션 테스트. 코드\\\filepath{test/helpers/sessions\_helper\_test.rb}} 

%= lang:ruby
\begin{code} 코드require 'test_helper' 

class SessionsHelperTest < ActionView::TestCase 

def setup @user = users(:michael) remember(@user) end 

test "current_user returns right user when session is nil" do assert_equal @user, current_user assert is_logged_in?코드end 

test "current_user returns nil when remember digest is wrong" do @user.update_attribute(:remember_digest, User.digest(User.new_token)) assert_nil current_user end end \end{code} \end{codelisting} 

\noindent 여기서 현재 사용자가 \kode{nil}인지 확인하는 두번째 테스트가 추가 된것을 주목하자. 만약 사용자의 기억하기 다이제스트가 기억하기 토큰과 맞지 않는지는 \kode{authenticated?}\ 으로 중첩하여 \kode{if} 문으로 테스트 했다: 

%= lang:ruby
\begin{code} if user &&user.authenticated?(cookies[:remember_token]) \end{code} 

필요한 테스트는 목록 \ref{code:persistent_sessions_test}과 같다 

\begin{codelisting} \codecaption코드{\failing} 

%= lang:text
\begin{code} $ bundle exec rake test TEST=test/helpers/sessions_helper_test.rb \end{code} \end{codelisting} 

목록~\ref{code:persistent_sessions_test}의 테스트를 통과 시키기 위해서 \kode{raise}을 제거하고 원래 \kode{current\_user} 메소드로 돌려 놓으면 된다 목록 \ref{code:branch_no_raise}. (목록 \ref{code:branch_no_raise}의 \kode{authenticated?}\  표현식을 제거해서 목록\ref{code:persistent_sessions_test}의 두번째 테스트가 실패하는 것으로 이 테스트가 제대로된 테스트임을 확인할 수 있다.) 

\begin{codelisting} \label{code:branch_no_raise} \codecaption{예외 발생 제거하기코드\passing \\\filepath{app/helpers/sessions\_helper.rb}} 

%= lang:ruby, options: "hl_lines": [9]
\begin{code} module SessionsHelper . 코드. 코드. # Returns the user corresponding to the remember token cookie. def current_user if (user_id = session[:user_id]) @current_user ||= User.find_by(id: user_id) elsif (user_id = cookies.signed[:user_id]) user = User.find_by(id: user_id) if user &&user.authenticated?(cookies[:remember_token]) log_in user @current_user = user end end end . 코드. 코드. 코드end \end{code} \end{codelisting} 

\noindent 이 시점에서, 테스트 스위트는 \passing이어야 한다. 

\begin{codelisting} \codecaption코드{\passing} 

%= lang:text
\begin{code} 코드$ bundle exec rake test \end{code} \end{codelisting} 

\noindent 이제 ``remember'' 브랜치에 \kode{current\_user}을 테스트했다. 이제 자신있게 손으로 테스트 해보지 않고 회고를 할 수 있다. 

% subsubsection testing_the_remember_branch (end)
% subsection remember_tests (end)
% section remember_me (end)
\section{결론} 

% (fold)
앞선 두개의 장에서 많은 부분은 처리했다. 설계했던 부분을 실제로 어플리케이션에 가입하고 로그인할 수 있는 기능을 모두 구현했다. 이제 남은 일은 로그인 상태나 사용자의 신원에 따라 각 페이지 별로 접근 제어만 걸면 된다. 이 작업은 \ref{cha:updating_showing_and_deleting_users} 장의 최종 목표인 사용자가 자신의 정보를 수정할 수 있도록 해주는 과정에서 해결될 것이다. 

다음으로 넘어가기 전에 우선 현재 브랜치를 마스터 브랜치에 머지하자. 

%= lang:text
\begin{code} $ bundle exec rake test $ git add -A $ git commit -m "Finish log in/log out" $ git checkout master $ git merge log-in-log-out \end{code} 

\noindent 그리고 리모트 저장소와 상용서버에 푸시하자: 

%= lang:text
\begin{code} $ bundle exec rake test $ git push $ git push heroku $ heroku run rake db:migrate \end{code} 

\noindent 마이그레이션이 끝나기전까지 어플리케이션이 잠시동안 정상이 아닌 상태가 됨을 주의하자상용 사이트가 많은 트래픽이 예상된다면 변경사항을 반영하기 전에 \href{https://devcenter.heroku.com/articles/maintenance-mode}{\emph{maintenance mode}}로 바꾸는 것도 좋은 방법이다: 

%= lang:text
\begin{code} $ heroku maintenance:on $ git push heroku $ heroku run rake db:migrate $ heroku maintenance:off \end{code} 

\noindent 이렇게 하면 배포와 마이그레이션이 진행되는 동안 표준 에러 화면을 보여준다. (이 부분은 다시 다루지 않을 것이다. 하지만 한번쯤은 이 부분을 살펴보는 것이 좋다.) 더 자세한 정보는 허로쿠 문서\href{https://devcenter.heroku.com/articles/error-pages}{error pages}을 참조하자. 

\subsection{이번 챕터에서 배운 것} \label{sec:log_in_out_what_we_learned_in_this_chapter} 

% (fold)
\begin{itemize} \item 레일즈는 한 페이지에서 다른 페이지로 이동할때 임시 또는 유지되는 쿠키를 사용하여 상태를 유지할 수 있다. \item 로그인 폼은 사용자가 로그인하면서 새로운 새션을 만들도록 설계했다. \item \kode{flash.now} 메서드는 화면에 플래시 메세지를 나타내는데 사용한다. \item 테스트 주도 개발방법은 테스트에 버그를 재생산하여 디버깅할때 유용하다. \item \kode{session} 메서드를 사용하여, 브라우저의 임시 세션을 생성하여 사용자 아이디를 안전하게 저장할 수 있다. \item로그인한 상태에 따라서 레이아웃의 링크를 변경할 수 있다. \item 통합 테스트는 라우트, 데이터베이스 업데이트, 레이아웃의 변화등을 검증할 수 있다. \item 각각 사용자의 기억하기 토큰과 이에 대응되는 기억하기 다이제스트를 엮어서 유지되는 세션을 구현할 수 있다. \item \kode{cookies} 메서드를 사용하여 브라우저에 영구적인 기억하기 토큰을 저장하여 유지되는 세션을 구현할 수 있다. \item 로그인 상태는 임시세션이나 영구적인 세션에 유일한 기억하기 토큰에 있는 세션의 사용자 아이디로 찾을 수 있는 사용자의 존재 여부에 따라 결정된다. \item 세션의 사용자 아이디을 지우거나 브라우저의 영구 쿠키값을 삭제하여 사용자를 로그아웃 시킬 수 있다. \item 삼항 연산자는 if-then 문을 간단하게 작성할 수 있게 해준다 \end{itemize} 

% subsection what_we_learned_in_this_chapter (end)
\section{연습문제} \label{sec:log_in_out_exercises} 

% (fold)
\input{chapters/exercises_note} \input{chapters/exercise_topic_branches} 

\begin{enumerate} 

\item 목록 \ref{code:user_model_remember}에서 새로운 토큰과 다이제스트 클래스 메서드를  \kode{User}로 시작하여 작성했다. 이 메서드들은 실제로 \kode{User.new\_token}와 \kode{User.digest} 같은 방식으로 \emph{호출되기 때문에}, 아마 가장 명료하게 정의 하는 방법일 것이다. 그러나 클래스 메서드를 정의 하는 더 관용적으로 더 바른 방법 두가지가 더 있다. 하나는 약간 혼란 스럽고, 또다른 하나는 엄청나게 혼란스럽다. 테스트 스위트를 실행시켜서 목록 \ref{code:token_digest_self}(약간 혼란스러운) 코드와 목록 \ref{code:token_digest_class_self}(엄청나게 혼란스러운) 두 코드가 모두 동작함을 확인 할 수 있다. (목록 \ref{code:token_digest_self}과 목록~\ref{code:token_digest_class_self}에 있는 \kode{self} 는 \kode{User} 클래스를 가리킨다. 반면에 사용자 모델 내에서 사용하는 \kode{self}는  \emph{인스턴스}객체를 가리킨다. 이 부분이 혼란스럽게 하는 부분이다.) 

\item 섹션~\ref{sec:remember_tests}에서 이민 지적했듯이 현재 어플리케이션은 설계상 통합 테스트에서 가상의 \kode{remember\_token} 속성에 접근할 수 있는 방법인 없다. 목록 \ref{code:remember_me_test}. 그러나 특수한 테스트 메서드인 \kode{assigns}응 용하여 가능하다. 테스트 내에서 컨트롤러 내에서 정의 되어 있는 \emph{인스턴스 } 변수를 \kode{assigns}에 변수에 해당하는 심벌을 주어 접근 할 수 있다. 예를 들어 \kode{create} 액션 내에 \kode{@user} 변수가 있다면, 테스트 내에서 \kode{assigns(:user)}로 접근이 가능하다. 현재 세션 컨트롤러에 \kode{create} 액션에서는 보통 (인스턴스 변수가 아닌) \kode{user} 변수를 정의 했다. 만약 이를 인스턴스 변수로 바꾸면 \kode{cookies}에 사용자의 기억하기 토큰이 제대로 저장되어 있는지 테스트 할 수 있다. 목록~\ref{code:login_create_user_instance} 과~목록 \ref{code:improved_remember_me_test}에 빠진 부분을(물음표\kode{?}와 \kode{FILL\_IN})으로 표시된 곳) 채워서 ``remember me'' 체크박스 테스트를 향상 시켜 보자. 

\end{enumerate} 

\begin{codelisting} \label{code:token_digest_self} \codecaption{ \kode{self}을 이용한 새로운 토큰과 다이제스트 메서드 정의. 코드\passing \\코드\filepath{app/models/user.rb}} 

%= lang:ruby, options: "hl_lines": [6, 13]
\begin{code} 코드class User < ActiveRecord::Base . 코드. 코드. # Returns the hash digest of the given string. def self.digest(string) cost = ActiveModel::SecurePassword.min_cost ?BCrypt::Engine::MIN_COST : BCrypt::Engine.cost BCrypt::Password.create(string, cost: cost) end 

# Returns a random token. def self.new_token SecureRandom.urlsafe_base64 end . 코드. 코드. 코드end \end{code} \end{codelisting} 

\begin{codelisting} \label{code:token_digest_class_self} \codecaption{\kode{class <\!< self}을 이용한 새로운 토큰과 다이제스트 메서드 정의. 코드\passing \\\filepath{app/models/user.rb}} 

%= lang:ruby, options: "hl_lines": [5, 7, 14]
\begin{code} 코드class User < ActiveRecord::Base . 코드. 코드. class << self # Returns the hash digest of the given string. def digest(string) cost = ActiveModel::SecurePassword.min_cost ?BCrypt::Engine::MIN_COST : BCrypt::Engine.cost BCrypt::Password.create(string, cost: cost) end 

# Returns a random token. def new_token SecureRandom.urlsafe_base64 end end . 코드. 코드. \end{code} \end{codelisting} 

\begin{codelisting} \label{code:login_create_user_instance} \codecaption{\kode인스턴스 변수를 사용하는 {create}액션 템플릿코드\\\filepath{app/controllers/sessions\_controller.rb}} 

%= lang:ruby, options: "hl_lines": [7, 8, 9, 10, 11]
\begin{code} class SessionsController < ApplicationController 

def new end 

def create ?user = User.find_by(email: params[:session][:email].downcase) if ?user &&?user.authenticate(params[:session][:password]) log_in ?user params[:session][:remember_me] == '1' ? remember(?user) : forget(?user) redirect_to ?user else flash.now[:danger] = 'Invalid email/password combination' render 'new' end end 

def destroy log_out if logged_in? redirect_to root_url end end \end{code} \end{codelisting} 

\begin{codelisting} \label{code:improved_remember_me_test} \codecaption{향상된 ``remember me'' 테스트 템플릿. 코드\passing \\\filepath{test/integration/users\_login\_test.rb}} 

%= lang:ruby, options: "hl_lines": [13]
\begin{code} 코드require 'test_helper' 

class UsersLoginTest < ActionDispatch::IntegrationTest 

def setup @user = users(:michael) end . 코드. 코드. test "login with remembering" do log_in_as(@user, remember_me: '1') assert_equal assigns(:user).FILL_IN, FILL_IN end 

test "login without remembering" do log_in_as(@user, remember_me: '0') assert_nil cookies['remember_token'] end . 코드. 코드. 코드end \end{code} \end{codelisting} 

% section exercises (end)
% chapter log_in_log_out (end)
